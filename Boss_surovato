import arcade
import math
import random
from arcade.gui import UIManager, UIAnchorLayout, UIBoxLayout, UIFlatButton

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
SCREEN_TITLE = "Epic Chess"

class BossFight(arcade.Window):
    def __init__(self):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, "Финальный Босс - ЭКСТРЕМАЛЬНЫЙ")

        # Инициализация игрока
        self.player_x = 400
        self.player_y = 100
        self.player_size = 30
        self.player_hp = 150
        self.player_max_hp = 150

        # Инициализация босса
        self.boss_x = SCREEN_WIDTH // 2
        self.boss_y = SCREEN_HEIGHT // 2
        self.boss_size = 40
        self.boss_hp = 500
        self.boss_max_hp = 500
        self.boss_invulnerable = False

        # Инициализация рук босса
        self.hands = []
        self.hand_length = 60
        self.hand_width = 10

        # Таймеры атак
        self.attack_timer = 0
        self.attack_interval = 90  # 1.5 секунды между атаками

        # Счетчики и фазы
        self.attack_counter = 0
        self.special_phase_after_attacks = 3
        self.attack_phase = "idle"
        self.attack_duration = 0
        self.special_phase_duration = 0
        self.special_phase_max_duration = 150

        # Опасные зоны
        self.danger_points = []
        self.danger_point_warnings = []
        self.danger_point_timer = 0
        self.danger_point_interval = 10
        self.warning_duration = 45

        # Секторы для рук
        self.hand_sectors = [
            (1, 60), (61, 120), (121, 180),
            (181, 240), (241, 300), (301, 360)
        ]

        # Таймеры контакта с руками
        self.hand_contact_timers = {}

        # Флаги для движения рук
        self.hands_moving = False
        self.hands_movement_timer = 0
        self.hands_movement_duration = 90  # 1.5 секунды движения рук

        # Управление
        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

    def setup(self):
        # Инициализация рук
        for i in range(6):
            start_angle, end_angle = self.hand_sectors[i]
            angle = random.randint(start_angle, end_angle)
            self.hands.append({
                "angle": math.radians(angle),
                "target_angle": math.radians(angle),
                "warning_timer": 0,
                "attacking": False,
                "attack_timer": 0,
                "speed_multiplier": 0.75,  # На 25% медленнее
                "current_angle": math.radians(angle),  # Текущий угол для плавного движения
                "move_progress": 0.0,  # Прогресс движения от 0 до 1
                "is_moving": False  # Флаг движения руки
            })

    def on_draw(self):
        self.clear()

        # Фон
        background_points = [
            (0, 0), (SCREEN_WIDTH, 0),
            (SCREEN_WIDTH, SCREEN_HEIGHT), (0, SCREEN_HEIGHT)
        ]
        arcade.draw_polygon_filled(background_points, arcade.color.DARK_SLATE_GRAY)

        # Предупреждения опасных точек
        for warning in self.danger_point_warnings:
            if warning["active"]:
                pulse_size = warning["size"] * (warning["timer"] / self.warning_duration)
                arcade.draw_circle_filled(warning["x"], warning["y"], pulse_size, (255, 255, 0))

        # Опасные точки
        for point in self.danger_points:
            if point["active"]:
                pulse_size = point["size"] + 8 * math.sin(point["timer"] * 0.3)
                arcade.draw_circle_filled(point["x"], point["y"], pulse_size, (255, 50, 50))

        # Босс
        if self.boss_invulnerable:
            pulse = 8 * math.sin(self.special_phase_duration * 0.3)
            arcade.draw_circle_filled(self.boss_x, self.boss_y, self.boss_size + pulse, (200, 50, 50))
        else:
            arcade.draw_circle_filled(self.boss_x, self.boss_y, self.boss_size, arcade.color.DARK_RED)

        # Руки (если не в особой фазе)
        if self.attack_phase != "special_phase":
            for i, hand in enumerate(self.hands):
                # Используем текущий угол для отрисовки (для плавного движения)
                current_angle = hand["current_angle"]

                x1 = self.boss_x + math.cos(current_angle) * self.hand_length
                y1 = self.boss_y + math.sin(current_angle) * self.hand_length
                x2 = x1 + math.cos(current_angle) * self.hand_length
                y2 = y1 + math.sin(current_angle) * self.hand_length

                # Выбор цвета в зависимости от состояния
                if hand["warning_timer"] > 0:
                    color = (255, 200, 0)
                    # Прозрачная линия предупреждения
                    arcade.draw_line(x2, y2, x2 + math.cos(current_angle) * 300,
                                     y2 + math.sin(current_angle) * 300, (255, 255, 0, 150), 25)
                elif hand["attacking"]:
                    color = (255, 255, 100)
                    # Луч атаки
                    arcade.draw_line(x2, y2, x2 + math.cos(current_angle) * 400,
                                     y2 + math.sin(current_angle) * 400, color, 25)
                else:
                    # Разный цвет в зависимости от того, движется ли рука
                    if hand["is_moving"]:
                        color = (180, 100, 80)  # Темнее при движении
                    else:
                        color = (220, 80, 60)  # Обычный цвет

                # Отрисовка руки
                arcade.draw_line(self.boss_x, self.boss_y, x1, y1, color, self.hand_width)
                arcade.draw_circle_filled(x1, y1, 12, color)
                arcade.draw_line(x1, y1, x2, y2, color, self.hand_width - 2)
                arcade.draw_circle_filled(x2, y2, 10, color)

        # Игрок
        half = self.player_size / 2
        points = [
            (self.player_x - half, self.player_y - half),
            (self.player_x + half, self.player_y - half),
            (self.player_x + half, self.player_y + half),
            (self.player_x - half, self.player_y + half),
        ]
        arcade.draw_polygon_filled(points, arcade.color.GREEN)

        # Интерфейс
        self.draw_interface()

    def draw_interface(self):
        # Здоровье игрока
        hp_width = 200 * (self.player_hp / self.player_max_hp)
        hp_points = [
            (20, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 20),
            (20, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_filled(hp_points, arcade.color.RED)
        arcade.draw_polygon_outline(hp_points, arcade.color.BLACK, 2)
        arcade.draw_text(f"Игрок: {int(self.player_hp)}/{self.player_max_hp}", 20, SCREEN_HEIGHT - 60,
                         arcade.color.WHITE, 18)

        # Здоровье босса
        boss_hp_width = 300 * (self.boss_hp / self.boss_max_hp)
        boss_hp_points = [
            (SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 40),
            (SCREEN_WIDTH // 2 - 150 + boss_hp_width, SCREEN_HEIGHT - 40),
            (SCREEN_WIDTH // 2 - 150 + boss_hp_width, SCREEN_HEIGHT - 20),
            (SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 20),
        ]
        boss_color = arcade.color.PURPLE if self.boss_invulnerable else arcade.color.DARK_RED
        arcade.draw_polygon_filled(boss_hp_points, boss_color)
        arcade.draw_polygon_outline(boss_hp_points, arcade.color.BLACK, 2)

        boss_hp_text = f"БОСС: {int(self.boss_hp)}/{self.boss_max_hp}"
        if self.boss_invulnerable:
            boss_hp_text += " (НЕУЯЗВИМ)"
        arcade.draw_text(boss_hp_text, SCREEN_WIDTH // 2, SCREEN_HEIGHT - 60, arcade.color.WHITE, 24, anchor_x="center")

        # Информация
        arcade.draw_text(f"Атак до особой фазы: {self.special_phase_after_attacks - self.attack_counter}",
                         SCREEN_WIDTH // 2, SCREEN_HEIGHT - 90, arcade.color.CYAN, 16, anchor_x="center")

        if self.attack_phase == "moving":
            time_left = self.hands_movement_duration - self.hands_movement_timer
            arcade.draw_text(f"Руки двигаются! Приготовьтесь! Осталось: {time_left / 60:.1f} сек",
                             SCREEN_WIDTH // 2, 100, arcade.color.ORANGE, 20, anchor_x="center")
        elif self.attack_phase == "warning":
            arcade.draw_text("ВНИМАНИЕ! Сейчас будет выстрел!", SCREEN_WIDTH // 2, 100, arcade.color.YELLOW, 20,
                             anchor_x="center")
        elif self.attack_phase == "attacking":
            arcade.draw_text("АТАКА! Уклоняйтесь от лучей и рук!", SCREEN_WIDTH // 2, 100, arcade.color.RED, 20,
                             anchor_x="center")
        elif self.attack_phase == "special_warning":
            arcade.draw_text("ОСОБАЯ ФАЗА! Руки исчезают!", SCREEN_WIDTH // 2, 100, arcade.color.PURPLE, 24,
                             anchor_x="center")
        elif self.attack_phase == "special_phase":
            time_left = self.special_phase_max_duration - self.special_phase_duration
            arcade.draw_text(f"ОСОБАЯ ФАЗА! Избегайте красных точек! Осталось: {time_left / 60:.1f} сек",
                             SCREEN_WIDTH // 2, 100, arcade.color.PURPLE, 20, anchor_x="center")

        if self.attack_phase == "idle":
            time_to_attack = max(0, (self.attack_interval - self.attack_timer) / 60)
            arcade.draw_text(f"Следующая атака через: {time_to_attack:.1f} сек", SCREEN_WIDTH // 2, 70,
                             arcade.color.CYAN, 16, anchor_x="center")

        # Экран окончания
        if self.player_hp <= 0 or self.boss_hp <= 0:
            self.draw_game_over_screen()

    def draw_game_over_screen(self):
        text_bg_points = [
            (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 100),
            (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 - 100),
            (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 + 100),
            (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 100),
        ]
        arcade.draw_polygon_filled(text_bg_points, arcade.color.BLACK)

        if self.player_hp <= 0:
            arcade.draw_text("ПОРАЖЕНИЕ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40, arcade.color.RED, 36,
                             anchor_x="center")
            arcade.draw_text("R - рестарт босса, ESC - выход", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20,
                             arcade.color.WHITE, 20, anchor_x="center")
        elif self.boss_hp <= 0:
            arcade.draw_text("ПОБЕДА НАД БОССОМ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40, arcade.color.GOLD, 36,
                             anchor_x="center")
            arcade.draw_text("Вы прошли игру!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20, arcade.color.WHITE, 24,
                             anchor_x="center")
            arcade.draw_text("ESC - выход", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50, arcade.color.YELLOW, 20,
                             anchor_x="center")

    def on_key_press(self, key, modifiers):
        if key == arcade.key.UP:
            self.up_pressed = True
        elif key == arcade.key.DOWN:
            self.down_pressed = True
        elif key == arcade.key.LEFT:
            self.left_pressed = True
        elif key == arcade.key.RIGHT:
            self.right_pressed = True
        elif key == arcade.key.SPACE:
            self.player_attack()
        elif key == arcade.key.R:
            self.restart_boss_fight()
        elif key == arcade.key.ESCAPE:
            arcade.close_window()

    def on_key_release(self, key, modifiers):
        if key == arcade.key.UP:
            self.up_pressed = False
        elif key == arcade.key.DOWN:
            self.down_pressed = False
        elif key == arcade.key.LEFT:
            self.left_pressed = False
        elif key == arcade.key.RIGHT:
            self.right_pressed = False

    def player_attack(self):
        if self.player_hp <= 0 or self.boss_hp <= 0 or self.boss_invulnerable:
            return

        attack_range = 80
        distance_x = abs(self.player_x - self.boss_x)
        distance_y = abs(self.player_y - self.boss_y)
        distance = (distance_x ** 2 + distance_y ** 2) ** 0.5

        if distance < attack_range + self.boss_size:
            self.boss_hp -= 10
            if self.boss_hp < 0:
                self.boss_hp = 0

    def update_hands(self):
        for i, hand in enumerate(self.hands):
            # Обновление движения рук
            if hand["is_moving"]:
                hand["move_progress"] += 0.008  # Медленное движение (~2 секунды на полный поворот)
                if hand["move_progress"] >= 1.0:
                    hand["move_progress"] = 1.0
                    hand["is_moving"] = False
                    hand["angle"] = hand["target_angle"]
                    hand["current_angle"] = hand["target_angle"]
                else:
                    # Плавная интерполяция между начальным и конечным углом
                    start_angle = hand.get("start_angle", hand["angle"])
                    hand["current_angle"] = start_angle + (hand["target_angle"] - start_angle) * hand["move_progress"]
            else:
                # Если не движемся, текущий угол равен целевому
                hand["current_angle"] = hand["angle"]

            # Обновление таймеров предупреждения и атаки
            if hand["warning_timer"] > 0:
                hand["warning_timer"] -= 1
                if hand["warning_timer"] <= 0:
                    hand["attacking"] = True
                    hand["attack_timer"] = 75  # 1.25 секунды выстрела

            if hand["attack_timer"] > 0:
                hand["attack_timer"] -= 1
                if hand["attack_timer"] <= 0:
                    hand["attacking"] = False

            # Урон от луча
            if hand["attacking"] and self.player_hp > 0:
                current_angle = hand["current_angle"]
                x1 = self.boss_x + math.cos(current_angle) * self.hand_length * 2
                y1 = self.boss_y + math.sin(current_angle) * self.hand_length * 2
                ray_dir_x = math.cos(current_angle)
                ray_dir_y = math.sin(current_angle)

                player_to_ray_x = self.player_x - x1
                player_to_ray_y = self.player_y - y1
                projection = player_to_ray_x * ray_dir_x + player_to_ray_y * ray_dir_y

                if projection > 0:
                    closest_x = x1 + ray_dir_x * projection
                    closest_y = y1 + ray_dir_y * projection
                    distance = ((self.player_x - closest_x) ** 2 + (self.player_y - closest_y) ** 2) ** 0.5

                    if distance < self.player_size + 20:
                        self.player_hp -= 8
                        if self.player_hp < 0:
                            self.player_hp = 0

            # Урон от прикосновения к рукам
            if not hand["attacking"] and self.player_hp > 0:
                current_angle = hand["current_angle"]
                x1 = self.boss_x + math.cos(current_angle) * self.hand_length
                y1 = self.boss_y + math.sin(current_angle) * self.hand_length
                x2 = x1 + math.cos(current_angle) * self.hand_length
                y2 = y1 + math.sin(current_angle) * self.hand_length

                hand_segments = [
                    (self.boss_x, self.boss_y, x1, y1),
                    (x1, y1, x2, y2)
                ]

                for seg_x1, seg_y1, seg_x2, seg_y2 in hand_segments:
                    seg_dx = seg_x2 - seg_x1
                    seg_dy = seg_y2 - seg_y1
                    seg_length = math.sqrt(seg_dx ** 2 + seg_dy ** 2)

                    if seg_length > 0:
                        seg_nx = seg_dx / seg_length
                        seg_ny = seg_dy / seg_length
                        to_player_x = self.player_x - seg_x1
                        to_player_y = self.player_y - seg_y1
                        projection = to_player_x * seg_nx + to_player_y * seg_ny
                        projection = max(0, min(seg_length, projection))
                        closest_x = seg_x1 + seg_nx * projection
                        closest_y = seg_y1 + seg_ny * projection
                        distance = math.sqrt((self.player_x - closest_x) ** 2 + (self.player_y - closest_y) ** 2)

                        if distance < self.player_size + self.hand_width:
                            hand_key = f"hand_{i}"
                            if hand_key not in self.hand_contact_timers:
                                self.hand_contact_timers[hand_key] = 0

                            if self.hand_contact_timers[hand_key] <= 0:
                                self.player_hp -= 5
                                if self.player_hp < 0:
                                    self.player_hp = 0
                                self.hand_contact_timers[hand_key] = 30

        # Обновление таймеров контакта
        for key in list(self.hand_contact_timers.keys()):
            self.hand_contact_timers[key] -= 1
            if self.hand_contact_timers[key] <= 0:
                del self.hand_contact_timers[key]

    def update_danger_points(self):
        # Обновление предупреждений
        for warning in self.danger_point_warnings[:]:
            warning["timer"] += 1
            if warning["timer"] >= self.warning_duration:
                self.danger_points.append({
                    "x": warning["x"],
                    "y": warning["y"],
                    "size": 30,
                    "timer": 0,
                    "active": True,
                    "duration": 75
                })
                self.danger_point_warnings.remove(warning)

        # Создание новых предупреждений
        self.danger_point_timer += 1
        if self.danger_point_timer >= self.danger_point_interval:
            self.danger_point_timer = 0
            x = random.randint(50, SCREEN_WIDTH - 50)
            y = random.randint(50, SCREEN_HEIGHT - 50)
            self.danger_point_warnings.append({
                "x": x,
                "y": y,
                "size": 40,
                "timer": 0,
                "active": True
            })

        # Обновление опасных точек
        for point in self.danger_points[:]:
            point["timer"] += 1
            point["duration"] -= 1

            if point["active"] and self.player_hp > 0:
                distance = ((self.player_x - point["x"]) ** 2 + (self.player_y - point["y"]) ** 2) ** 0.5
                if distance < self.player_size + point["size"]:
                    self.player_hp -= 4
                    if self.player_hp < 0:
                        self.player_hp = 0

            if point["duration"] <= 0:
                self.danger_points.remove(point)

    def start_attack(self):
        # Фаза движения рук
        self.attack_phase = "moving"
        self.hands_movement_timer = 0

        # Устанавливаем новые целевые углы для рук
        for i, hand in enumerate(self.hands):
            start_angle, end_angle = self.hand_sectors[i]
            new_angle = random.randint(start_angle, end_angle)

            # Сохраняем начальный угол для плавного движения
            hand["start_angle"] = hand["angle"]
            hand["target_angle"] = math.radians(new_angle)
            hand["move_progress"] = 0.0
            hand["is_moving"] = True
            hand["warning_timer"] = 0
            hand["attacking"] = False

    def start_special_phase(self):
        self.attack_phase = "special_warning"
        self.attack_duration = 30
        self.boss_invulnerable = True
        self.danger_point_warnings = []
        self.danger_points = []

    def on_update(self, delta_time):
        if self.player_hp <= 0 or self.boss_hp <= 0:
            return

        # Движение игрока
        speed = 8
        if self.up_pressed:
            self.player_y += speed
        if self.down_pressed:
            self.player_y -= speed
        if self.left_pressed:
            self.player_x -= speed
        if self.right_pressed:
            self.player_x += speed

        self.player_x = max(self.player_size, min(SCREEN_WIDTH - self.player_size, self.player_x))
        self.player_y = max(self.player_size, min(SCREEN_HEIGHT - self.player_size, self.player_y))

        # Обновление механик босса
        if self.attack_phase != "special_phase":
            self.update_hands()

        if self.attack_phase == "special_phase":
            self.update_danger_points()
            self.special_phase_duration += 1

            if self.special_phase_duration >= self.special_phase_max_duration:
                self.attack_phase = "idle"
                self.boss_invulnerable = False
                self.danger_point_warnings = []
                self.danger_points = []
                self.special_phase_duration = 0
                self.attack_counter = 0

        # Управление фазами атаки
        if self.attack_phase == "idle":
            self.attack_timer += 1
            if self.attack_timer >= self.attack_interval:
                self.start_attack()
                self.attack_timer = 0

        elif self.attack_phase == "moving":
            self.hands_movement_timer += 1

            # После 1-2 секунд движения (90-120 кадров) начинаем предупреждение
            if self.hands_movement_timer >= 90:  # 1.5 секунды движения
                # Проверяем, все ли руки закончили движение
                all_ready = True
                for hand in self.hands:
                    if hand["is_moving"]:
                        all_ready = False
                        break

                if all_ready:
                    self.attack_phase = "warning"
                    self.attack_duration = 48  # 0.8 секунды предупреждения

                    # Устанавливаем предупреждение для всех рук
                    for hand in self.hands:
                        hand["warning_timer"] = 48

        elif self.attack_phase == "warning":
            self.attack_duration -= 1
            if self.attack_duration <= 0:
                self.attack_phase = "attacking"
                self.attack_counter += 1

                if self.attack_counter >= self.special_phase_after_attacks:
                    self.start_special_phase()

        elif self.attack_phase == "attacking":
            all_done = True
            for hand in self.hands:
                if hand["attack_timer"] > 0:
                    all_done = False
                    break

            if all_done:
                self.attack_phase = "idle"

        elif self.attack_phase == "special_warning":
            self.attack_duration -= 1
            if self.attack_duration <= 0:
                self.attack_phase = "special_phase"
                self.special_phase_duration = 0

    def restart_boss_fight(self):
        # Сброс игрока
        self.player_x = 400
        self.player_y = 100
        self.player_hp = 150
        self.player_max_hp = 150

        # Сброс босса
        self.boss_hp = 500
        self.boss_max_hp = 500
        self.boss_invulnerable = False

        # Сброс таймеров и фаз
        self.attack_timer = 0
        self.attack_phase = "idle"
        self.attack_counter = 0
        self.special_phase_duration = 0
        self.hands_movement_timer = 0

        # Очистка опасных зон
        self.danger_point_warnings = []
        self.danger_points = []
        self.hand_contact_timers = {}

        # Сброс рук
        self.hands = []
        self.setup()

        # Сброс управления
        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False
