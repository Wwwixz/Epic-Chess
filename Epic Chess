import arcade
import math
import random
import os
from arcade.gui import UIManager, UIAnchorLayout, UIBoxLayout, UIFlatButton
from datetime import datetime
from PIL import Image

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
SCREEN_TITLE = "Epic Chess"


class SimpleSprite:
    def __init__(self, center_x=0, center_y=0, texture=None, scale=1.0):
        self.center_x = center_x
        self.center_y = center_y
        self.texture = texture
        self.scale = scale
        self.angle = 0

    def draw(self):
        if self.texture:
            left = self.center_x - (self.texture.width * self.scale) / 2
            bottom = self.center_y - (self.texture.height * self.scale) / 2
            width = self.texture.width * self.scale
            height = self.texture.height * self.scale
            rect = arcade.LBWH(left, bottom, width, height)
            arcade.draw_texture_rect(self.texture, rect, angle=self.angle)
        else:
            arcade.draw_circle_filled(self.center_x, self.center_y, 20, arcade.color.BLUE)


class AnimatedSprite:
    def __init__(self, x, y, scale=1.0):
        self.x = x
        self.y = y
        self.scale = scale
        self.sprite = SimpleSprite(x, y, scale=scale)
        self.current_state = "idle"
        self.facing_right = True
        self.textures = {}
        self.animation_speed = 0.1
        self.time_since_last_frame = 0
        self.current_frame = 0
        self.sprite_width = 64
        self.sprite_height = 64

    def load_textures(self, base_path, states_dict):
        for state, frame_count in states_dict.items():
            state_textures = []
            for i in range(1, frame_count + 1):
                try:
                    texture_path = f"{base_path}/{state}/{i}.png"
                    texture = arcade.load_texture(texture_path)
                except:
                    if "player" in base_path:
                        color = (0, 200, 0) if state == "idle" else (0, 255, 0) if state == "run" else (255, 255, 0)
                    elif "monster" in base_path:
                        color = (200, 0, 0) if state == "idle" else (255, 0, 0) if state == "run" else (255, 100, 0)
                    elif "boss" in base_path:
                        if "hands" in base_path:
                            color = (200, 50, 100)
                        else:
                            color = (150, 0, 0) if state == "idle" else (200, 0, 0) if state == "damage" else (
                            255, 0, 0)
                    else:
                        color = (100, 100, 100)

                    img = Image.new('RGBA', (64, 64), color + (255,))
                    texture = arcade.Texture.create_empty(f"{state}_{i}", (64, 64))
                    texture.image = img
                state_textures.append(texture)
            self.textures[state] = state_textures

        if "idle" in self.textures and self.textures["idle"]:
            self.sprite.texture = self.textures["idle"][0]
        elif "run" in self.textures and self.textures["run"]:
            self.sprite.texture = self.textures["run"][0]

    def update_animation(self, delta_time):
        if self.sprite is None or self.current_state not in self.textures:
            return
        textures = self.textures[self.current_state]
        if not textures:
            return
        self.time_since_last_frame += delta_time
        if self.time_since_last_frame >= self.animation_speed:
            self.time_since_last_frame = 0
            self.current_frame = (self.current_frame + 1) % len(textures)
            texture = textures[self.current_frame]
            self.sprite.angle = 0
            self.sprite.texture = texture

    def set_state(self, state, face_right=True):
        if state != self.current_state and state in self.textures:
            self.current_state = state
            self.current_frame = 0
            self.facing_right = face_right
            if self.textures[state]:
                texture = self.textures[state][0]
                self.sprite.angle = 0
                if self.sprite:
                    self.sprite.texture = texture

    def update_position(self, x, y):
        self.x = x
        self.y = y
        self.sprite.center_x = x
        self.sprite.center_y = y

    def get_hitbox(self):
        half_width = (self.sprite_width * self.scale) / 2
        half_height = (self.sprite_height * self.scale) / 2
        return (self.x - half_width, self.y - half_height, self.x + half_width, self.y + half_height)

    def draw(self):
        self.sprite.center_x = self.x
        self.sprite.center_y = self.y
        self.sprite.draw()


class MainMenu(arcade.Window):
    def __init__(self):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)
        self.manager = UIManager()
        self.manager.enable()
        self.anchor_layout = UIAnchorLayout()
        self.box_layout = UIBoxLayout(vertical=True, space_between=10)
        self.setup_widgets()
        self.anchor_layout.add(self.box_layout)
        self.manager.add(self.anchor_layout)
        self.game_start_time = None
        self.background_music = None
        self.music_player = None
        self.music_volume = 0.5
        self.background_texture = None
        try:
            self.background_texture = arcade.load_texture("assets/backgrounds/main_menu.png")
        except:
            pass

    def setup_widgets(self):
        start_button = UIFlatButton(text="Играть", width=200, height=50)
        start_button.on_click = self.on_start_click
        exit_button = UIFlatButton(text="Выход", width=200, height=50)
        exit_button.on_click = self.on_exit_click
        self.box_layout.add(start_button)
        self.box_layout.add(exit_button)

    def on_show(self):
        self.play_music("Menu")

    def play_music(self, track_name):
        try:
            music_path = f"music/{track_name}.mp3"
            if os.path.exists(music_path):
                if self.background_music:
                    self.background_music.stop(self.music_player)
                self.background_music = arcade.load_sound(music_path, streaming=True)
                self.music_player = self.background_music.play(self.music_volume, loop=True)
        except Exception as e:
            print(f"Ошибка музыки: {e}")

    def stop_music(self):
        if self.background_music and self.music_player:
            self.background_music.stop(self.music_player)
            self.background_music = None
            self.music_player = None

    def on_start_click(self, event):
        self.stop_music()
        self.close()
        self.game_start_time = datetime.now()
        game = Level1(self.game_start_time)
        game.center_window()
        game.setup()
        game.play_music("Level1")
        arcade.run()

    def on_exit_click(self, event):
        self.stop_music()
        arcade.close_window()

    def on_draw(self):
        self.clear()
        if self.background_texture:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_texture_rect(self.background_texture, rect)
        else:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_rect_filled(rect, arcade.color.LIGHT_GRAY)

        overlay_rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
        arcade.draw_rect_filled(overlay_rect, (0, 0, 0, 100))

        arcade.draw_text("EPIC CHESS", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 80, arcade.color.GOLD, 48, anchor_x="center",
                         bold=True)
        arcade.draw_text("Управление в игре:", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 110, arcade.color.WHITE, 24,
                         anchor_x="center")
        arcade.draw_text("Стрелки - движение", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 150, arcade.color.WHITE, 18,
                         anchor_x="center")
        arcade.draw_text("Пробел - атака", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 170, arcade.color.WHITE, 18,
                         anchor_x="center")
        arcade.draw_text("ENTER - начать игру", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 190, arcade.color.WHITE, 18,
                         anchor_x="center")
        arcade.draw_text("R - главное меню, ESC - выход", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 210, arcade.color.WHITE,
                         18, anchor_x="center")
        self.manager.draw()

    def on_key_press(self, key, modifiers):
        if key == arcade.key.ENTER:
            self.on_start_click(None)


class Level1(arcade.Window):
    def __init__(self, start_time):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)
        self.start_time = start_time
        self.final_time = None
        self.game_paused = False
        self.game_ended = False
        self.level = 1
        self.background_texture = None
        try:
            self.background_texture = arcade.load_texture("assets/backgrounds/level1.png")
        except:
            pass

        self.player_x = 400
        self.player_y = 300
        self.player_speed = 8
        self.player_hp = 100
        self.player_max_hp = 100
        self.player_attacking = False
        self.player_attack_frame = 0

        self.player_sprite = AnimatedSprite(self.player_x, self.player_y, scale=1.0)

        self.monsters = []
        self.total_monsters = 4
        monster_positions = [(200, 300), (600, 300), (400, 100), (400, 500)]
        for pos in monster_positions:
            monster = {
                "x": pos[0], "y": pos[1], "alive": True,
                "hp": 80, "max_hp": 80, "attack_timer": 180,
                "sprite": AnimatedSprite(pos[0], pos[1], scale=0.8)
            }
            self.monsters.append(monster)

        self.teleport_active = False
        self.teleport_x = 100
        self.teleport_y = 100
        self.teleport_size = 40
        self.teleport_animation = 0

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

        self.chits_1 = False
        self.hart = 18

        self.kills = 0
        self.frame_count = 0
        self.background_music = None
        self.music_player = None
        self.music_volume = 0.5

    def play_music(self, track_name):
        try:
            music_path = f"music/{track_name}.mp3"
            if os.path.exists(music_path):
                if self.background_music and self.music_player:
                    self.background_music.stop(self.music_player)
                self.background_music = arcade.load_sound(music_path, streaming=True)
                self.music_player = self.background_music.play(self.music_volume, loop=True)
        except Exception as e:
            print(f"Ошибка музыки: {e}")

    def stop_music(self):
        if self.background_music and self.music_player:
            self.background_music.stop(self.music_player)
            self.background_music = None
            self.music_player = None

    def setup(self):
        self.player_sprite.load_textures("assets/sprites/player", {"idle": 1, "run": 8, "attack": 6})
        for monster in self.monsters:
            monster["sprite"].load_textures("assets/sprites/monsters/level1", {"idle": 1, "run": 6, "attack": 4})

    def on_draw(self):
        self.clear()
        if self.background_texture:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_texture_rect(self.background_texture, rect)
        else:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_rect_filled(rect, arcade.color.LIGHT_GRAY)

        for monster in self.monsters:
            if monster["alive"]:
                monster["sprite"].update_position(monster["x"], monster["y"])
                monster["sprite"].draw()
                if monster["hp"] < monster["max_hp"]:
                    hp_width = 40 * (monster["hp"] / monster["max_hp"])
                    hp_rect = arcade.LBWH(monster["x"] - 20, monster["y"] + 40 - 2.5, hp_width, 5)
                    arcade.draw_rect_filled(hp_rect, arcade.color.GREEN)
                    border_rect = arcade.LBWH(monster["x"] - 20, monster["y"] + 40 - 2.5, 40, 5)
                    arcade.draw_rect_outline(border_rect, arcade.color.BLACK, 1)
                if monster["attack_timer"] < 180:
                    attack_width = 40 * ((180 - monster["attack_timer"]) / 180)
                    attack_rect = arcade.LBWH(monster["x"] - 20, monster["y"] + 50 - 2.5, attack_width, 5)
                    arcade.draw_rect_filled(attack_rect, arcade.color.YELLOW)
                    attack_border_rect = arcade.LBWH(monster["x"] - 20, monster["y"] + 50 - 2.5, 40, 5)
                    arcade.draw_rect_outline(attack_border_rect, arcade.color.BLACK, 1)

        self.player_sprite.update_position(self.player_x, self.player_y)
        self.player_sprite.draw()

        if self.teleport_active:
            self.teleport_animation += 1
            pulse = abs(20 * (self.teleport_animation % 60 - 30) / 30)
            arcade.draw_circle_filled(self.teleport_x, self.teleport_y, self.teleport_size + pulse, arcade.color.PURPLE)
            arcade.draw_circle_outline(self.teleport_x, self.teleport_y, self.teleport_size + pulse + 5,
                                       arcade.color.BLACK, 3)
            for i in range(8):
                angle = self.teleport_animation * 0.1 + i * math.pi / 4
                x1 = self.teleport_x + (self.teleport_size + pulse) * math.cos(angle)
                y1 = self.teleport_y + (self.teleport_size + pulse) * math.sin(angle)
                x2 = self.teleport_x + (self.teleport_size + pulse + 15) * math.cos(angle)
                y2 = self.teleport_y + (self.teleport_size + pulse + 15) * math.sin(angle)
                arcade.draw_line(x1, y1, x2, y2, arcade.color.YELLOW, 3)

        hp_width = 200 * (self.player_hp / self.player_max_hp)
        hp_rect = arcade.LBWH(20, SCREEN_HEIGHT - 40, hp_width, 20)
        arcade.draw_rect_filled(hp_rect, arcade.color.RED)
        hp_border_rect = arcade.LBWH(20, SCREEN_HEIGHT - 40, 200, 20)
        arcade.draw_rect_outline(hp_border_rect, arcade.color.BLACK, 2)

        if not self.game_ended:
            current_time = datetime.now()
            elapsed = current_time - self.start_time
            elapsed_str = str(elapsed).split('.')[0]
        else:
            elapsed_str = str(self.final_time).split('.')[0] if self.final_time else "00:00:00"

        arcade.draw_text(f"Время: {elapsed_str}", 20, SCREEN_HEIGHT - 220, (0, 100, 255), 16)
        arcade.draw_text(f"HP: {int(self.player_hp)}/{self.player_max_hp}", 20, SCREEN_HEIGHT - 60, (0, 100, 255), 18)
        arcade.draw_text(f"Убито: {self.kills}/{self.total_monsters}", 20, SCREEN_HEIGHT - 90, (0, 100, 255), 18)
        arcade.draw_text(f"Уровень: {self.level}", 20, SCREEN_HEIGHT - 115, (0, 100, 255), 18)

        if self.teleport_active:
            arcade.draw_text("Подойдите к телепорту", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 40, arcade.color.PURPLE, 24,
                             anchor_x="center")

        if self.player_hp <= 0:
            game_over_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT // 2 - 100, 400, 150)
            arcade.draw_rect_filled(game_over_rect, arcade.color.BLACK)
            arcade.draw_rect_outline(game_over_rect, arcade.color.WHITE, 2)
            arcade.draw_text("ВЫ ПРОИГРАЛИ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20, arcade.color.RED, 36,
                             anchor_x="center")
            arcade.draw_text(f"Убито монстров: {self.kills}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20,
                             arcade.color.WHITE, 24, anchor_x="center")
            arcade.draw_text(f"Время: {elapsed_str}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 45, arcade.color.WHITE,
                             20, anchor_x="center")
            arcade.draw_text("R - главное меню", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 70, arcade.color.YELLOW, 20,
                             anchor_x="center")

        if self.game_paused:
            pause_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 80, 400, 160)
            arcade.draw_rect_filled(pause_rect, (0, 0, 0, 200))
            arcade.draw_rect_outline(pause_rect, arcade.color.YELLOW, 2)
            arcade.draw_text("ИГРА ПРИОСТАНОВЛЕНА", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30, arcade.color.WHITE, 32,
                             anchor_x="center")
            arcade.draw_text("P - продолжить", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30, arcade.color.YELLOW, 24,
                             anchor_x="center")

    def on_key_press(self, key, modifiers):
        if key == arcade.key.P:
            self.game_paused = not self.game_paused
            return
        if key == arcade.key.C:
            self.chits_1 = not self.chits_1
            self.hart = 90 if self.chits_1 else 18
            return
        if self.game_paused:
            return
        if key == arcade.key.R:
            self.return_to_main_menu()
            return
        if self.player_hp <= 0:
            if key == arcade.key.R:
                self.return_to_main_menu()
            return
        if key == arcade.key.UP:
            self.up_pressed = True
        elif key == arcade.key.DOWN:
            self.down_pressed = True
        elif key == arcade.key.LEFT:
            self.left_pressed = True
        elif key == arcade.key.RIGHT:
            self.right_pressed = True
        elif key == arcade.key.SPACE:
            if not self.player_attacking:
                self.player_attack()
        elif key == arcade.key.ESCAPE:
            arcade.close_window()

    def on_key_release(self, key, modifiers):
        if self.game_paused:
            return
        if key == arcade.key.UP:
            self.up_pressed = False
        elif key == arcade.key.DOWN:
            self.down_pressed = False
        elif key == arcade.key.LEFT:
            self.left_pressed = False
        elif key == arcade.key.RIGHT:
            self.right_pressed = False

    def player_attack(self):
        if self.player_attacking:
            return
        self.player_attacking = True
        self.player_attack_frame = 0
        face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
        self.player_sprite.set_state("attack", face_right)
        attack_range = 96
        damage = self.hart
        for monster in self.monsters:
            if not monster["alive"]:
                continue
            distance_x = abs(self.player_x - monster["x"])
            distance_y = abs(self.player_y - monster["y"])
            if distance_x < attack_range and distance_y < attack_range:
                monster["hp"] -= damage
                monster["sprite"].set_state("attack")
                if monster["hp"] <= 0:
                    monster["alive"] = False
                    self.kills += 1
                    self.check_teleport_spawn()

    def check_teleport_spawn(self):
        all_dead = all(not monster["alive"] for monster in self.monsters)
        if all_dead and not self.teleport_active:
            self.spawn_teleport()

    def spawn_teleport(self):
        possible_locations = [(100, 100), (SCREEN_WIDTH - 100, 100), (100, SCREEN_HEIGHT - 100),
                              (SCREEN_WIDTH - 100, SCREEN_HEIGHT - 100)]
        self.teleport_x, self.teleport_y = random.choice(possible_locations)
        self.teleport_active = True
        self.teleport_animation = 0

    def update_monsters(self):
        move_speed = 2
        min_distance = 50
        for i, monster in enumerate(self.monsters):
            if not monster["alive"]:
                continue
            target_x = self.player_x
            target_y = self.player_y
            for j, other in enumerate(self.monsters):
                if i == j or not other["alive"]:
                    continue
                dx = monster["x"] - other["x"]
                dy = monster["y"] - other["y"]
                distance = (dx ** 2 + dy ** 2) ** 0.5
                if distance < min_distance:
                    if distance == 0:
                        distance = 0.001
                    repel_force = (min_distance - distance) / min_distance
                    target_x += dx / distance * repel_force * 50
                    target_y += dy / distance * repel_force * 50
            dx = target_x - monster["x"]
            if monster["attack_timer"] <= 0 and self.player_hp > 0:
                distance_x = abs(self.player_x - monster["x"])
                distance_y = abs(self.player_y - monster["y"])
                monster_attack_range = 80
                if distance_x < monster_attack_range and distance_y < monster_attack_range:
                    self.player_hp -= 5
                    monster["attack_timer"] = 180
                    monster["sprite"].set_state("attack")
                elif abs(dx) > 0.5:
                    monster["sprite"].set_state("run", dx > 0)
                elif monster["sprite"].current_state == "attack" and monster["attack_timer"] <= 0:
                    monster["sprite"].set_state("idle", monster["sprite"].facing_right)
            else:
                if abs(dx) > 0.5:
                    monster["sprite"].set_state("run", dx > 0)
                elif monster["sprite"].current_state == "attack" and monster["attack_timer"] <= 0:
                    monster["sprite"].set_state("idle", monster["sprite"].facing_right)
            if monster["attack_timer"] > 0:
                monster["attack_timer"] -= 1
            else:
                if monster["x"] < target_x:
                    monster["x"] += move_speed
                elif monster["x"] > target_x:
                    monster["x"] -= move_speed
                if monster["y"] < target_y:
                    monster["y"] += move_speed
                elif monster["y"] > target_y:
                    monster["y"] -= move_speed
            monster["x"] = max(20, min(SCREEN_WIDTH - 20, monster["x"]))
            monster["y"] = max(20, min(SCREEN_HEIGHT - 20, monster["y"]))
            monster["sprite"].update_position(monster["x"], monster["y"])

    def on_update(self, delta_time):
        if self.game_paused or self.game_ended:
            return
        self.frame_count += 1
        if self.player_hp <= 0:
            if not self.final_time:
                self.final_time = datetime.now() - self.start_time
                self.game_ended = True
            return
        self.player_sprite.update_animation(delta_time)
        if self.player_attacking:
            self.player_attack_frame += 1
            if self.player_attack_frame >= 30:
                self.player_attacking = False
                self.player_attack_frame = 0
                face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
                self.player_sprite.set_state("idle", face_right)
        move_x = 0
        move_y = 0
        if not self.player_attacking:
            if self.up_pressed:
                move_y += self.player_speed
            if self.down_pressed:
                move_y -= self.player_speed
            if self.left_pressed:
                move_x -= self.player_speed
            if self.right_pressed:
                move_x += self.player_speed
        if move_x != 0 or move_y != 0:
            self.player_x += move_x
            self.player_y += move_y
            if move_x != 0 and not self.player_attacking:
                self.player_sprite.set_state("run", move_x > 0)
            elif not self.player_attacking:
                face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
                self.player_sprite.set_state("run", face_right)
        elif not self.player_attacking and self.player_attack_frame == 0:
            face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
            self.player_sprite.set_state("idle", face_right)
        self.player_x = max(20, min(SCREEN_WIDTH - 20, self.player_x))
        self.player_y = max(20, min(SCREEN_HEIGHT - 20, self.player_y))
        for monster in self.monsters:
            if monster["alive"]:
                monster["sprite"].update_animation(delta_time)
        if not self.teleport_active:
            self.update_monsters()
        else:
            distance_to_teleport = ((self.player_x - self.teleport_x) ** 2 + (
                        self.player_y - self.teleport_y) ** 2) ** 0.5
            if distance_to_teleport < self.teleport_size + 20:
                self.go_to_level2()

    def go_to_level2(self):
        self.stop_music()
        self.final_time = datetime.now() - self.start_time
        self.game_ended = True
        self.close()
        level2 = Level2(self.start_time)
        level2.center_window()
        level2.setup()
        level2.play_music("Level2")
        arcade.run()

    def return_to_main_menu(self):
        self.stop_music()
        self.close()
        menu = MainMenu()
        menu.center_window()
        arcade.run()


class Level2(arcade.Window):
    def __init__(self, start_time):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)
        self.start_time = start_time
        self.final_time = None
        self.game_paused = False
        self.game_ended = False
        self.level = 2
        self.background_texture = None
        try:
            self.background_texture = arcade.load_texture("assets/backgrounds/level2.png")
        except:
            pass

        self.player_x = 400
        self.player_y = 300
        self.player_speed = 8
        self.player_hp = 100
        self.player_max_hp = 100
        self.player_attacking = False
        self.player_attack_frame = 0

        self.player_sprite = AnimatedSprite(self.player_x, self.player_y, scale=1.0)

        self.chits_1 = False
        self.hart = 18

        self.bishops = []
        self.total_bishops = 5
        bishop_positions = [(150, 150), (650, 150), (150, 450), (650, 450), (400, 300)]
        bishop_sizes = [30, 30, 30, 30, 35]
        bishop_hps = [156, 156, 156, 156, 195]

        for i, pos in enumerate(bishop_positions):
            bishop = {
                "x": pos[0], "y": pos[1], "alive": True,
                "hp": bishop_hps[i], "max_hp": bishop_hps[i],
                "attack_timer": 108, "size": bishop_sizes[i],
                "sprite": AnimatedSprite(pos[0], pos[1], scale=0.9 if i < 4 else 1.0)
            }
            self.bishops.append(bishop)

        self.rooks = []
        self.rooks_timer = 0
        self.rooks_interval = 600

        self.teleport_active = False
        self.teleport_x = 100
        self.teleport_y = 100
        self.teleport_size = 40
        self.teleport_animation = 0

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

        self.kills = 0
        self.frame_count = 0
        self.background_music = None
        self.music_player = None
        self.music_volume = 0.5

    def play_music(self, track_name):
        try:
            music_path = f"music/{track_name}.mp3"
            if os.path.exists(music_path):
                if self.background_music and self.music_player:
                    self.background_music.stop(self.music_player)
                self.background_music = arcade.load_sound(music_path, streaming=True)
                self.music_player = self.background_music.play(self.music_volume, loop=True)
        except Exception as e:
            print(f"Ошибка музыки: {e}")

    def stop_music(self):
        if self.background_music and self.music_player:
            self.background_music.stop(self.music_player)
            self.background_music = None
            self.music_player = None

    def setup(self):
        self.player_sprite.load_textures("assets/sprites/player", {"idle": 1, "run": 8, "attack": 6})
        for bishop in self.bishops:
            bishop["sprite"].load_textures("assets/sprites/monsters/level2/bishop", {"idle": 1, "run": 6, "attack": 4})
        self.create_rooks()

    def create_rooks(self):
        self.rooks = []
        rook1 = {"x": -100, "y": SCREEN_HEIGHT - 170, "speed": 5, "direction": 1, "active": True, "damage_cooldown": 0,
                 "sprite": AnimatedSprite(-100, SCREEN_HEIGHT - 170, scale=1.2)}
        try:
            rook1["sprite"].load_textures("assets/sprites/monsters/level2/rook1", {"run": 8})
        except:
            try:
                textures = []
                for i in range(1, 9):
                    texture = arcade.load_texture(f"assets/sprites/monsters/level2/rook1/run/{i}.png")
                    textures.append(texture)
                rook1["sprite"].textures = {"run": textures}
                rook1["sprite"].sprite.texture = textures[0]
            except:
                color = (100, 100, 200)
                img = Image.new('RGBA', (64, 64), color + (255,))
                texture = arcade.Texture.create_empty("rook1", (64, 64))
                texture.image = img
                rook1["sprite"].textures = {"run": [texture]}
                rook1["sprite"].sprite.texture = texture
        rook1["sprite"].set_state("run", True)

        rook2 = {"x": SCREEN_WIDTH + 100, "y": 170, "speed": 5, "direction": -1, "active": True, "damage_cooldown": 0,
                 "sprite": AnimatedSprite(SCREEN_WIDTH + 100, 170, scale=1.2)}
        try:
            rook2["sprite"].load_textures("assets/sprites/monsters/level2/rook2", {"run": 8})
        except:
            try:
                textures = []
                for i in range(1, 9):
                    texture = arcade.load_texture(f"assets/sprites/monsters/level2/rook2/run/{i}.png")
                    textures.append(texture)
                rook2["sprite"].textures = {"run": textures}
                rook2["sprite"].sprite.texture = textures[0]
            except:
                color = (200, 100, 100)
                img = Image.new('RGBA', (64, 64), color + (255,))
                texture = arcade.Texture.create_empty("rook2", (64, 64))
                texture.image = img
                rook2["sprite"].textures = {"run": [texture]}
                rook2["sprite"].sprite.texture = texture
        rook2["sprite"].set_state("run", False)

        self.rooks.append(rook1)
        self.rooks.append(rook2)

    def on_draw(self):
        self.clear()
        if self.background_texture:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_texture_rect(self.background_texture, rect)
        else:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_rect_filled(rect, arcade.color.DARK_SLATE_GRAY)

        for bishop in self.bishops:
            if bishop["alive"]:
                bishop["sprite"].update_position(bishop["x"], bishop["y"])
                bishop["sprite"].draw()
                if bishop["hp"] < bishop["max_hp"]:
                    hp_width = bishop["size"] * (bishop["hp"] / bishop["max_hp"])
                    hp_rect = arcade.LBWH(bishop["x"] - bishop["size"] / 2, bishop["y"] + bishop["size"] + 15 - 2.5,
                                          hp_width, 5)
                    arcade.draw_rect_filled(hp_rect, arcade.color.GREEN)
                    border_rect = arcade.LBWH(bishop["x"] - bishop["size"] / 2, bishop["y"] + bishop["size"] + 15 - 2.5,
                                              bishop["size"], 5)
                    arcade.draw_rect_outline(border_rect, arcade.color.BLACK, 1)
                if bishop["attack_timer"] < 108:
                    attack_width = bishop["size"] * ((108 - bishop["attack_timer"]) / 108)
                    attack_rect = arcade.LBWH(bishop["x"] - bishop["size"] / 2, bishop["y"] + bishop["size"] + 25 - 2.5,
                                              attack_width, 5)
                    arcade.draw_rect_filled(attack_rect, arcade.color.YELLOW)
                    attack_border_rect = arcade.LBWH(bishop["x"] - bishop["size"] / 2,
                                                     bishop["y"] + bishop["size"] + 25 - 2.5, bishop["size"], 5)
                    arcade.draw_rect_outline(attack_border_rect, arcade.color.BLACK, 1)

        for rook in self.rooks:
            if rook["active"]:
                rook["sprite"].update_position(rook["x"], rook["y"])
                rook["sprite"].draw()

        self.player_sprite.update_position(self.player_x, self.player_y)
        self.player_sprite.draw()

        if self.teleport_active:
            self.teleport_animation += 1
            pulse = abs(20 * (self.teleport_animation % 60 - 30) / 30)
            arcade.draw_circle_filled(self.teleport_x, self.teleport_y, self.teleport_size + pulse, arcade.color.PURPLE)
            arcade.draw_circle_outline(self.teleport_x, self.teleport_y, self.teleport_size + pulse + 5,
                                       arcade.color.BLACK, 3)
            for i in range(8):
                angle = self.teleport_animation * 0.1 + i * math.pi / 4
                x1 = self.teleport_x + (self.teleport_size + pulse) * math.cos(angle)
                y1 = self.teleport_y + (self.teleport_size + pulse) * math.sin(angle)
                x2 = self.teleport_x + (self.teleport_size + pulse + 15) * math.cos(angle)
                y2 = self.teleport_y + (self.teleport_size + pulse + 15) * math.sin(angle)
                arcade.draw_line(x1, y1, x2, y2, arcade.color.YELLOW, 3)

        hp_width = 200 * (self.player_hp / self.player_max_hp)
        hp_rect = arcade.LBWH(20, SCREEN_HEIGHT - 40, hp_width, 20)
        arcade.draw_rect_filled(hp_rect, arcade.color.RED)
        hp_border_rect = arcade.LBWH(20, SCREEN_HEIGHT - 40, 200, 20)
        arcade.draw_rect_outline(hp_border_rect, arcade.color.BLACK, 2)

        if not self.game_ended:
            current_time = datetime.now()
            elapsed = current_time - self.start_time
            elapsed_str = str(elapsed).split('.')[0]
        else:
            elapsed_str = str(self.final_time).split('.')[0] if self.final_time else "00:00:00"

        arcade.draw_text(f"Время: {elapsed_str}", 20, SCREEN_HEIGHT - 220, (0, 100, 255), 16)
        arcade.draw_text(f"HP: {int(self.player_hp)}/{self.player_max_hp}", 20, SCREEN_HEIGHT - 60, (0, 100, 255), 18)
        arcade.draw_text(f"Убито: {self.kills}/{self.total_bishops}", 20, SCREEN_HEIGHT - 90, (0, 100, 255), 18)
        arcade.draw_text(f"Уровень: {self.level}", 20, SCREEN_HEIGHT - 115, (0, 100, 255), 18)

        if self.teleport_active:
            arcade.draw_text("Подойдите к телепорту", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 40, arcade.color.PURPLE, 24,
                             anchor_x="center")

        if self.player_hp <= 0:
            game_over_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 60, 400, 120)
            arcade.draw_rect_filled(game_over_rect, arcade.color.BLACK)
            arcade.draw_rect_outline(game_over_rect, arcade.color.WHITE, 2)
            arcade.draw_text("ВЫ ПРОИГРАЛИ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20, arcade.color.RED, 36,
                             anchor_x="center")
            arcade.draw_text(f"Убито монстров: {self.kills}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20,
                             arcade.color.WHITE, 24, anchor_x="center")
            arcade.draw_text(f"Время: {elapsed_str}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 45, arcade.color.WHITE,
                             20, anchor_x="center")
            arcade.draw_text("R - главное меню", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 70, arcade.color.YELLOW, 20,
                             anchor_x="center")

        if self.game_paused:
            pause_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 80, 400, 160)
            arcade.draw_rect_filled(pause_rect, (0, 0, 0, 200))
            arcade.draw_rect_outline(pause_rect, arcade.color.YELLOW, 2)
            arcade.draw_text("ИГРА ПРИОСТАНОВЛЕНА", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30, arcade.color.WHITE, 32,
                             anchor_x="center")
            arcade.draw_text("P - продолжить", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30, arcade.color.YELLOW, 24,
                             anchor_x="center")

        if self.teleport_active and all(not bishop["alive"] for bishop in self.bishops):
            distance_to_teleport = ((self.player_x - self.teleport_x) ** 2 + (
                        self.player_y - self.teleport_y) ** 2) ** 0.5
            if distance_to_teleport < self.teleport_size + 20:
                self.show_victory()

    def show_victory(self):
        if not self.final_time:
            self.final_time = datetime.now() - self.start_time
            self.game_ended = True
        victory_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 310, SCREEN_HEIGHT // 2 - 100, 620, 200)
        arcade.draw_rect_filled(victory_rect, arcade.color.DARK_BLUE)
        arcade.draw_rect_outline(victory_rect, arcade.color.GOLD, 3)
        arcade.draw_text("ПОБЕДА!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50, arcade.color.GOLD, 48,
                         anchor_x="center", bold=True)
        arcade.draw_text("Нажмите SPACE для финального босса", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2,
                         arcade.color.WHITE, 28, anchor_x="center")
        elapsed_str = str(self.final_time).split('.')[0] if self.final_time else "00:00:00"
        arcade.draw_text(f"Общее время: {elapsed_str}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 40, arcade.color.YELLOW,
                         24, anchor_x="center")
        arcade.draw_text("R - главное меню", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80, arcade.color.GREEN, 22,
                         anchor_x="center")

    def on_key_press(self, key, modifiers):
        if key == arcade.key.P:
            self.game_paused = not self.game_paused
            return
        if key == arcade.key.C:
            self.chits_1 = not self.chits_1
            self.hart = 90 if self.chits_1 else 18
            return
        if self.game_paused:
            return
        if key == arcade.key.R:
            self.return_to_main_menu()
            return
        if self.player_hp <= 0 or self.game_ended:
            if key == arcade.key.R:
                self.return_to_main_menu()
            elif key == arcade.key.SPACE and self.game_ended and all(not bishop["alive"] for bishop in self.bishops):
                self.stop_music()
                self.close()
                boss_fight = BossFight(self.start_time)
                boss_fight.center_window()
                boss_fight.setup()
                boss_fight.play_music("Level3")
                arcade.run()
            return
        if key == arcade.key.UP:
            self.up_pressed = True
        elif key == arcade.key.DOWN:
            self.down_pressed = True
        elif key == arcade.key.LEFT:
            self.left_pressed = True
        elif key == arcade.key.RIGHT:
            self.right_pressed = True
        elif key == arcade.key.SPACE:
            if not self.player_attacking:
                self.player_attack()
        elif key == arcade.key.ESCAPE:
            arcade.close_window()

    def on_key_release(self, key, modifiers):
        if self.game_paused:
            return
        if key == arcade.key.UP:
            self.up_pressed = False
        elif key == arcade.key.DOWN:
            self.down_pressed = False
        elif key == arcade.key.LEFT:
            self.left_pressed = False
        elif key == arcade.key.RIGHT:
            self.right_pressed = False

    def player_attack(self):
        if self.player_attacking:
            return
        self.player_attacking = True
        self.player_attack_frame = 0
        face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
        self.player_sprite.set_state("attack", face_right)
        attack_range = 96
        damage = self.hart
        for bishop in self.bishops:
            if not bishop["alive"]:
                continue
            distance_x = abs(self.player_x - bishop["x"])
            distance_y = abs(self.player_y - bishop["y"])
            if distance_x < attack_range and distance_y < attack_range:
                bishop["hp"] -= damage
                bishop["sprite"].set_state("attack")
                if bishop["hp"] <= 0:
                    bishop["alive"] = False
                    self.kills += 1
                    self.check_teleport_spawn()

    def check_teleport_spawn(self):
        all_dead = all(not bishop["alive"] for bishop in self.bishops)
        if all_dead and not self.teleport_active:
            self.spawn_teleport()

    def spawn_teleport(self):
        possible_locations = [(100, 100), (SCREEN_WIDTH - 100, 100), (100, SCREEN_HEIGHT - 100),
                              (SCREEN_WIDTH - 100, SCREEN_HEIGHT - 100)]
        self.teleport_x, self.teleport_y = random.choice(possible_locations)
        self.teleport_active = True
        self.teleport_animation = 0

    def check_collision(self, sprite1, sprite2):
        left1, bottom1, right1, top1 = sprite1.get_hitbox()
        left2, bottom2, right2, top2 = sprite2.get_hitbox()
        return (right1 > left2 and left1 < right2 and top1 > bottom2 and bottom1 < top2)

    def update_rooks(self, delta_time):
        self.rooks_timer += 1
        if self.rooks_timer >= self.rooks_interval and len(self.rooks) == 0:
            self.rooks_timer = 0
            self.create_rooks()
        rooks_to_remove = []
        for i, rook in enumerate(self.rooks):
            if rook["active"]:
                rook["x"] += rook["speed"] * rook["direction"]
                if "run" in rook["sprite"].textures:
                    rook["sprite"].update_animation(delta_time)
                rook["sprite"].update_position(rook["x"], rook["y"])
                if rook["damage_cooldown"] > 0:
                    rook["damage_cooldown"] -= 1
                if (rook["direction"] == 1 and rook["x"] > SCREEN_WIDTH + 150) or (
                        rook["direction"] == -1 and rook["x"] < -150):
                    rooks_to_remove.append(i)
        for i in sorted(rooks_to_remove, reverse=True):
            if i < len(self.rooks):
                self.rooks.pop(i)

    def handle_rook_collisions(self):
        for rook in self.rooks:
            if not rook["active"] or rook["damage_cooldown"] > 0:
                continue
            if self.check_collision(rook["sprite"], self.player_sprite):
                self.player_hp -= 30
                rook["damage_cooldown"] = 30
                if rook["direction"] == 1:
                    self.player_x = max(20, self.player_x - 50)
                else:
                    self.player_x = min(SCREEN_WIDTH - 20, self.player_x + 50)
            for bishop in self.bishops:
                if not bishop["alive"]:
                    continue
                if self.check_collision(rook["sprite"], bishop["sprite"]):
                    bishop["hp"] -= 50
                    rook["damage_cooldown"] = 30
                    if rook["direction"] == 1:
                        bishop["y"] = max(bishop["size"], bishop["y"] - 50)
                        bishop["x"] = min(SCREEN_WIDTH - bishop["size"], bishop["x"] + 30)
                    else:
                        bishop["y"] = min(SCREEN_HEIGHT - bishop["size"], bishop["y"] + 50)
                        bishop["x"] = max(bishop["size"], bishop["x"] - 30)
                    if bishop["hp"] <= 0:
                        bishop["alive"] = False
                        self.kills += 1
                        self.check_teleport_spawn()

    def update_bishops(self):
        move_speed = 2.5
        min_distance = 50
        for i, bishop in enumerate(self.bishops):
            if not bishop["alive"]:
                continue
            target_x = self.player_x
            target_y = self.player_y
            for j, other in enumerate(self.bishops):
                if i == j or not other["alive"]:
                    continue
                dx = bishop["x"] - other["x"]
                dy = bishop["y"] - other["y"]
                distance = (dx ** 2 + dy ** 2) ** 0.5
                if distance < min_distance:
                    if distance == 0:
                        distance = 0.001
                    repel_force = (min_distance - distance) / min_distance
                    target_x += dx / distance * repel_force * 50
                    target_y += dy / distance * repel_force * 50
            dx = target_x - bishop["x"]
            if bishop["attack_timer"] <= 0 and self.player_hp > 0:
                distance_x = abs(self.player_x - bishop["x"])
                distance_y = abs(self.player_y - bishop["y"])
                bishop_attack_range = 80
                if distance_x < bishop_attack_range and distance_y < bishop_attack_range:
                    self.player_hp -= 8
                    bishop["attack_timer"] = 108
                    bishop["sprite"].set_state("attack")
                elif abs(dx) > 0.5:
                    bishop["sprite"].set_state("run", dx > 0)
                elif bishop["sprite"].current_state == "attack" and bishop["attack_timer"] <= 0:
                    bishop["sprite"].set_state("idle", bishop["sprite"].facing_right)
            else:
                if abs(dx) > 0.5:
                    bishop["sprite"].set_state("run", dx > 0)
                elif bishop["sprite"].current_state == "attack" and bishop["attack_timer"] <= 0:
                    bishop["sprite"].set_state("idle", bishop["sprite"].facing_right)
            if bishop["attack_timer"] > 0:
                bishop["attack_timer"] -= 1
            else:
                if bishop["x"] < target_x:
                    bishop["x"] += move_speed
                elif bishop["x"] > target_x:
                    bishop["x"] -= move_speed
                if bishop["y"] < target_y:
                    bishop["y"] += move_speed
                elif bishop["y"] > target_y:
                    bishop["y"] -= move_speed
            bishop["x"] = max(bishop["size"], min(SCREEN_WIDTH - bishop["size"], bishop["x"]))
            bishop["y"] = max(bishop["size"], min(SCREEN_HEIGHT - bishop["size"], bishop["y"]))
            bishop["sprite"].update_position(bishop["x"], bishop["y"])

    def on_update(self, delta_time):
        if self.game_paused or self.game_ended:
            return
        self.frame_count += 1
        if self.player_hp <= 0:
            if not self.final_time:
                self.final_time = datetime.now() - self.start_time
                self.game_ended = True
            return
        self.player_sprite.update_animation(delta_time)
        if self.player_attacking:
            self.player_attack_frame += 1
            if self.player_attack_frame >= 30:
                self.player_attacking = False
                self.player_attack_frame = 0
                face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
                self.player_sprite.set_state("idle", face_right)
        move_x = 0
        move_y = 0
        if not self.player_attacking:
            if self.up_pressed:
                move_y += self.player_speed
            if self.down_pressed:
                move_y -= self.player_speed
            if self.left_pressed:
                move_x -= self.player_speed
            if self.right_pressed:
                move_x += self.player_speed
        if move_x != 0 or move_y != 0:
            self.player_x += move_x
            self.player_y += move_y
            if move_x != 0 and not self.player_attacking:
                self.player_sprite.set_state("run", move_x > 0)
            elif not self.player_attacking:
                face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
                self.player_sprite.set_state("run", face_right)
        elif not self.player_attacking and self.player_attack_frame == 0:
            face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
            self.player_sprite.set_state("idle", face_right)
        self.player_x = max(20, min(SCREEN_WIDTH - 20, self.player_x))
        self.player_y = max(20, min(SCREEN_HEIGHT - 20, self.player_y))
        for bishop in self.bishops:
            if bishop["alive"]:
                bishop["sprite"].update_animation(delta_time)
        self.update_rooks(delta_time)
        self.handle_rook_collisions()
        if not self.teleport_active:
            self.update_bishops()

    def return_to_main_menu(self):
        self.stop_music()
        self.close()
        menu = MainMenu()
        menu.center_window()
        arcade.run()


class BossFight(arcade.Window):
    def __init__(self, start_time):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, "Финальный Босс - ЭКСТРЕМАЛЬНЫЙ")
        self.start_time = start_time
        self.final_time = None
        self.game_paused = False
        self.game_ended = False
        self.background_texture = None
        try:
            self.background_texture = arcade.load_texture("assets/backgrounds/boss.png")
        except:
            pass

        self.player_x = 400
        self.player_y = 100
        self.player_speed = 8
        self.player_hp = 120
        self.player_max_hp = 120
        self.player_attacking = False
        self.player_attack_frame = 0
        self.player_damage_dealt = False
        self.player_invulnerable = False
        self.player_invulnerable_timer = 0

        self.player_sprite = AnimatedSprite(self.player_x, self.player_y, scale=1.0)
        self.boss_sprite = AnimatedSprite(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, scale=1.19)

        self.boss_x = SCREEN_WIDTH // 2
        self.boss_y = SCREEN_HEIGHT // 2
        self.boss_size = 38
        self.boss_hp = 500
        self.boss_max_hp = 500
        self.boss_invulnerable = False
        self.death_phase_active = False
        self.victory_achieved = False

        self.hands = []
        self.hand_textures = []
        self.hand_width = 24
        self.hand_height = 64

        self.attack_timer = 0
        self.attack_interval = 180

        self.attack_counter = 0
        self.special_phase_after_attacks = 3
        self.attack_phase = "idle"
        self.attack_duration = 0
        self.special_phase_duration = 0
        self.special_phase_max_duration = 540

        self.danger_points = []
        self.danger_point_warnings = []
        self.explosions = []
        self.danger_point_timer = 0
        self.danger_point_interval = 30
        self.warning_duration = 60

        self.hand_sectors = [(0, 60), (60, 120), (120, 180), (180, 240), (240, 300), (300, 360)]

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False
        self.background_music = None
        self.music_player = None
        self.music_volume = 0.5
        self.victory_music_played = False
        self.defeat_music_played = False

    def play_music(self, track_name):
        try:
            music_path = f"music/{track_name}.mp3"
            if os.path.exists(music_path):
                if self.background_music and self.music_player:
                    self.background_music.stop(self.music_player)
                self.background_music = arcade.load_sound(music_path, streaming=True)
                self.music_player = self.background_music.play(self.music_volume, loop=True)
        except Exception as e:
            print(f"Ошибка музыки: {e}")

    def stop_music(self):
        if self.background_music and self.music_player:
            self.background_music.stop(self.music_player)
            self.background_music = None
            self.music_player = None

    def play_victory_music(self):
        if not self.victory_music_played:
            self.stop_music()
            self.play_music("Win")
            self.victory_music_played = True

    def play_defeat_music(self):
        if not self.defeat_music_played:
            self.stop_music()
            self.play_music("Lose")
            self.defeat_music_played = True

    def setup(self):
        self.player_sprite.load_textures("assets/sprites/player", {"idle": 1, "run": 8, "attack": 6})
        self.boss_sprite.load_textures("assets/sprites/boss/body", {"idle": 4, "damage": 3})
        self.boss_sprite.animation_speed = 0.2

        for i in range(1, 3):
            try:
                texture = arcade.load_texture(f"assets/sprites/boss/hands/{i}.png")
                self.hand_textures.append(texture)
            except:
                color = (200, 50, 100)
                img = Image.new('RGBA', (self.hand_width, self.hand_height), color + (255,))
                texture = arcade.Texture.create_empty(f"hand_{i}", (self.hand_width, self.hand_height))
                texture.image = img
                self.hand_textures.append(texture)

        for i in range(6):
            start_angle, end_angle = self.hand_sectors[i]
            angle = random.randint(start_angle, end_angle)
            angle_rad = math.radians(angle)

            hand_sprite = SimpleSprite(self.boss_x, self.boss_y, scale=1.75)
            hand_sprite.texture = self.hand_textures[0]

            self.hands.append({
                "angle": angle_rad,
                "target_angle": angle_rad,
                "current_angle": angle_rad,
                "warning_timer": 0,
                "attacking": False,
                "attack_timer": 0,
                "animation_frame": 0,
                "animation_timer": 0,
                "sprite": hand_sprite,
                "show_preview": False,
                "preview_angle": angle_rad,
                "damage_cooldown": 0
            })

    def on_draw(self):
        self.clear()
        if self.background_texture:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_texture_rect(self.background_texture, rect)
        else:
            rect = arcade.LBWH(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
            arcade.draw_rect_filled(rect, arcade.color.DARK_SLATE_GRAY)

        for hand in self.hands:
            if self.attack_phase != "special_phase" and not self.death_phase_active:
                if hand["attacking"]:
                    hand["sprite"].texture = self.hand_textures[hand["animation_frame"]]
                else:
                    hand["sprite"].texture = self.hand_textures[0]
                hand["sprite"].center_x = self.boss_x
                hand["sprite"].center_y = self.boss_y
                hand["sprite"].angle = math.degrees(hand["current_angle"])
                hand["sprite"].draw()

        self.boss_sprite.update_position(self.boss_x, self.boss_y)
        self.boss_sprite.draw()

        for hand in self.hands:
            if hand["show_preview"] and not hand[
                "attacking"] and self.attack_phase != "special_phase" and not self.death_phase_active:
                preview_angle = hand["preview_angle"]
                ray_length = 400
                ray_end_x = self.boss_x + math.cos(preview_angle) * ray_length
                ray_end_y = self.boss_y + math.sin(preview_angle) * ray_length
                arcade.draw_line(self.boss_x, self.boss_y, ray_end_x, ray_end_y, (255, 255, 0, 128), 8)

        for hand in self.hands:
            if hand["attacking"] and not self.death_phase_active:
                current_angle = hand["current_angle"]
                ray_length = 400
                ray_end_x = self.boss_x + math.cos(current_angle) * ray_length
                ray_end_y = self.boss_y + math.sin(current_angle) * ray_length
                ray_thickness = 15 + 5 * math.sin(hand["attack_timer"] * 0.2)
                arcade.draw_line(self.boss_x, self.boss_y, ray_end_x, ray_end_y, (255, 0, 0), ray_thickness)
                end_pulse = 20 + 10 * math.sin(hand["attack_timer"] * 0.3)
                arcade.draw_circle_filled(ray_end_x, ray_end_y, end_pulse, (255, 50, 50, 150))

        for warning in self.danger_point_warnings:
            if warning["active"]:
                pulse_size = warning["size"] * (warning["timer"] / self.warning_duration)
                arcade.draw_circle_filled(warning["x"], warning["y"], pulse_size, (255, 255, 0, 150))

        for explosion in self.explosions:
            if explosion["active"]:
                explosion["sprite"].draw()

        for point in self.danger_points:
            if point["active"]:
                pulse_size = point["size"] + 8 * math.sin(point["timer"] * 0.3)
                arcade.draw_circle_filled(point["x"], point["y"], pulse_size, (255, 50, 50, 150))

        if not (self.player_invulnerable and (self.player_invulnerable_timer % 10 < 5)):
            self.player_sprite.update_position(self.player_x, self.player_y)
            self.player_sprite.draw()

        hp_width = 200 * (self.player_hp / self.player_max_hp)
        hp_rect = arcade.LBWH(20, SCREEN_HEIGHT - 40, hp_width, 20)
        arcade.draw_rect_filled(hp_rect, arcade.color.RED)
        hp_border_rect = arcade.LBWH(20, SCREEN_HEIGHT - 40, 200, 20)
        arcade.draw_rect_outline(hp_border_rect, arcade.color.BLACK, 2)

        boss_hp_width = 300 * (self.boss_hp / self.boss_max_hp)
        boss_color = arcade.color.PURPLE if self.boss_invulnerable else arcade.color.DARK_RED
        boss_hp_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 40, boss_hp_width, 20)
        arcade.draw_rect_filled(boss_hp_rect, boss_color)
        boss_hp_border_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 40, 300, 20)
        arcade.draw_rect_outline(boss_hp_border_rect, arcade.color.BLACK, 2)

        if not self.game_ended:
            current_time = datetime.now()
            elapsed = current_time - self.start_time
            elapsed_str = str(elapsed).split('.')[0]
        else:
            elapsed_str = str(self.final_time).split('.')[0] if self.final_time else "00:00:00"

        arcade.draw_text(f"Общее время: {elapsed_str}", 20, SCREEN_HEIGHT - 220, (0, 100, 255), 16)
        arcade.draw_text(f"Игрок: {int(self.player_hp)}/{self.player_max_hp}", 20, SCREEN_HEIGHT - 60, (0, 100, 255),
                         18)

        boss_hp_text = f"БОСС: {int(self.boss_hp)}/{self.boss_max_hp}"
        if self.boss_invulnerable:
            boss_hp_text += " (НЕУЯЗВИМ)"
        arcade.draw_text(boss_hp_text, SCREEN_WIDTH // 2, SCREEN_HEIGHT - 60, (138, 43, 226), 24, anchor_x="center")

        arcade.draw_text(f"Атак до особой фазы: {max(0, self.special_phase_after_attacks - self.attack_counter)}",
                         SCREEN_WIDTH // 2, SCREEN_HEIGHT - 110, (138, 43, 226), 16, anchor_x="center")

        if self.death_phase_active:
            time_left = max(0, (self.special_phase_max_duration - self.special_phase_duration) // 60)
            arcade.draw_text(f"ПРЕДСМЕРТНАЯ ФАЗА! Осталось: {time_left} сек", SCREEN_WIDTH // 2, 100,
                             (255, 0, 0), 24, anchor_x="center")
        elif self.attack_phase == "idle":
            time_to_attack = max(0, (self.attack_interval - self.attack_timer) // 60)
            arcade.draw_text(f"Следующая атака через: {time_to_attack} сек", SCREEN_WIDTH // 2, 70, (138, 43, 226), 16,
                             anchor_x="center")
        elif self.attack_phase == "moving":
            time_left = max(0, (120 - self.attack_duration) // 60)
            arcade.draw_text(f"Руки двигаются! Приготовьтесь! Осталось: {time_left} сек", SCREEN_WIDTH // 2, 100,
                             (138, 43, 226), 20, anchor_x="center")
        elif self.attack_phase == "warning":
            time_left = max(0, self.attack_duration // 60)
            arcade.draw_text(f"ВНИМАНИЕ! Атака через: {time_left} сек", SCREEN_WIDTH // 2, 100, (138, 43, 226), 20,
                             anchor_x="center")
        elif self.attack_phase == "attacking":
            arcade.draw_text("АТАКА! Уклоняйтесь от лучей!", SCREEN_WIDTH // 2, 100, (138, 43, 226), 20,
                             anchor_x="center")
        elif self.attack_phase == "special_warning":
            time_left = max(0, self.attack_duration // 60)
            arcade.draw_text(f"ОСОБАЯ ФАЗА через: {time_left} сек", SCREEN_WIDTH // 2, 100, (138, 43, 226), 24,
                             anchor_x="center")
        elif self.attack_phase == "special_phase":
            time_left = max(0, (self.special_phase_max_duration - self.special_phase_duration) // 60)
            arcade.draw_text(f"ОСОБАЯ ФАЗА! Уклоняйтесь от взрывов! Осталось: {time_left} сек", SCREEN_WIDTH // 2, 100,
                             (138, 43, 226), 20, anchor_x="center")

        if self.player_hp <= 0 or self.victory_achieved:
            self.draw_game_over_screen()

        if self.game_paused:
            self.draw_pause_screen()

    def draw_game_over_screen(self):
        if not self.final_time:
            self.final_time = datetime.now() - self.start_time
            self.game_ended = True
        elapsed_str = str(self.final_time).split('.')[0] if self.final_time else "00:00:00"
        game_over_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 60, 400, 120)
        arcade.draw_rect_filled(game_over_rect, arcade.color.BLACK)
        arcade.draw_rect_outline(game_over_rect, arcade.color.WHITE, 2)
        if self.player_hp <= 0:
            arcade.draw_text("ВЫ ПРОИГРАЛИ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20, arcade.color.RED, 36,
                             anchor_x="center")
        elif self.victory_achieved:
            arcade.draw_text("ПОБЕДА!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20, arcade.color.GOLD, 36,
                             anchor_x="center")
        arcade.draw_text(f"Время: {elapsed_str}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20, arcade.color.WHITE, 24,
                         anchor_x="center")
        arcade.draw_text("R - главное меню", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50, arcade.color.YELLOW, 20,
                         anchor_x="center")

    def draw_pause_screen(self):
        pause_rect = arcade.LBWH(SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 80, 400, 160)
        arcade.draw_rect_filled(pause_rect, (0, 0, 0, 200))
        arcade.draw_rect_outline(pause_rect, arcade.color.YELLOW, 2)
        arcade.draw_text("ИГРА ПРИОСТАНОВЛЕНА", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30, arcade.color.WHITE, 32,
                         anchor_x="center")
        arcade.draw_text("P - продолжить", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30, arcade.color.YELLOW, 24,
                         anchor_x="center")

    def on_key_press(self, key, modifiers):
        if key == arcade.key.P:
            self.game_paused = not self.game_paused
            return
        if self.game_paused:
            return
        if key == arcade.key.R:
            self.return_to_main_menu()
            return
        if self.player_hp <= 0 or self.victory_achieved:
            if key == arcade.key.R:
                self.return_to_main_menu()
            return
        if key == arcade.key.UP:
            self.up_pressed = True
        elif key == arcade.key.DOWN:
            self.down_pressed = True
        elif key == arcade.key.LEFT:
            self.left_pressed = True
        elif key == arcade.key.RIGHT:
            self.right_pressed = True
        elif key == arcade.key.SPACE:
            if not self.player_attacking:
                self.player_attack()
        elif key == arcade.key.ESCAPE:
            arcade.close_window()

    def on_key_release(self, key, modifiers):
        if self.game_paused:
            return
        if key == arcade.key.UP:
            self.up_pressed = False
        elif key == arcade.key.DOWN:
            self.down_pressed = False
        elif key == arcade.key.LEFT:
            self.left_pressed = False
        elif key == arcade.key.RIGHT:
            self.right_pressed = False

    def player_attack(self):
        if self.player_hp <= 0 or self.boss_invulnerable or self.death_phase_active:
            return
        if self.player_attacking:
            return
        self.player_attacking = True
        self.player_attack_frame = 0
        self.player_damage_dealt = False
        face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
        self.player_sprite.set_state("attack", face_right)

    def apply_player_damage(self):
        if not self.player_damage_dealt and self.player_attacking and self.player_attack_frame >= 15:
            attack_range = 128
            distance_x = abs(self.player_x - self.boss_x)
            distance_y = abs(self.player_y - self.boss_y)
            distance = (distance_x ** 2 + distance_y ** 2) ** 0.5
            if distance < attack_range + self.boss_size:
                damage = int(18 * 1.75 * 0.42)
                self.boss_hp -= damage
                if self.boss_hp < 0:
                    self.boss_hp = 0

                if self.boss_hp <= 0 and not self.death_phase_active:
                    self.start_death_phase()

                self.player_damage_dealt = True

    def start_death_phase(self):
        self.death_phase_active = True
        self.boss_invulnerable = True
        self.attack_phase = "death_phase"
        self.special_phase_duration = 0
        self.danger_point_interval = 15
        self.boss_sprite.set_state("damage")

    def check_hand_collision(self):
        if self.player_invulnerable or self.death_phase_active:
            return

        player_radius = 20
        for hand in self.hands:
            if hand["damage_cooldown"] > 0:
                hand["damage_cooldown"] -= 1
                continue

            hand_length = 40 * 1.75
            hand_width = self.boss_size

            hand_tip_x = self.boss_x + math.cos(hand["current_angle"]) * hand_length
            hand_tip_y = self.boss_y + math.sin(hand["current_angle"]) * hand_length

            distance_to_tip = math.sqrt((self.player_x - hand_tip_x) ** 2 + (self.player_y - hand_tip_y) ** 2)

            if distance_to_tip < player_radius + hand_width:
                self.player_hp -= 20
                self.player_invulnerable = True
                self.player_invulnerable_timer = 60
                hand["damage_cooldown"] = 30

                dx = self.player_x - self.boss_x
                dy = self.player_y - self.boss_y
                dist = math.sqrt(dx * dx + dy * dy)
                if dist > 0:
                    dx /= dist
                    dy /= dist
                self.player_x += dx * 40
                self.player_y += dy * 40
                return

    def update_hand_positions(self):
        for hand in self.hands:
            if self.attack_phase == "moving":
                t = self.attack_duration / 120.0
                diff = hand["target_angle"] - hand["angle"]
                while diff > math.pi:
                    diff -= 2 * math.pi
                while diff < -math.pi:
                    diff += 2 * math.pi
                hand["current_angle"] = hand["angle"] + diff * t
                hand["preview_angle"] = hand["current_angle"]
                hand["show_preview"] = True
            elif self.attack_phase == "warning":
                hand["current_angle"] = hand["target_angle"]
                hand["preview_angle"] = hand["target_angle"]
                hand["show_preview"] = True
            else:
                hand["current_angle"] = hand["angle"]
                if self.attack_phase == "attacking" and hand["attacking"]:
                    hand["show_preview"] = False
                else:
                    hand["show_preview"] = False

            hand["sprite"].center_x = self.boss_x
            hand["sprite"].center_y = self.boss_y
            hand["sprite"].angle = math.degrees(hand["current_angle"])

    def start_attack(self):
        self.attack_phase = "moving"
        self.attack_duration = 0
        for i, hand in enumerate(self.hands):
            start_angle, end_angle = self.hand_sectors[i]
            new_angle = random.randint(start_angle, end_angle)
            new_angle_rad = math.radians(new_angle)
            hand["target_angle"] = new_angle_rad
            hand["warning_timer"] = 0
            hand["attacking"] = False
            hand["attack_timer"] = 0
            hand["animation_frame"] = 0
            hand["animation_timer"] = 0
            hand["show_preview"] = True
            hand["damage_cooldown"] = 0

    def start_special_phase(self):
        self.attack_phase = "special_warning"
        self.attack_duration = 60
        self.boss_invulnerable = True
        self.danger_point_warnings = []
        self.danger_points = []
        self.explosions = []
        for hand in self.hands:
            hand["show_preview"] = False
        self.boss_sprite.set_state("damage")

    def check_hand_collisions(self):
        if self.player_invulnerable or self.death_phase_active:
            return

        player_radius = 20
        for hand in self.hands:
            if not hand["attacking"]:
                continue
            if hand["attack_timer"] > 0:
                current_angle = hand["current_angle"]
                ray_length = 400
                A = self.player_x - self.boss_x
                B = self.player_y - self.boss_y
                C = math.cos(current_angle) * ray_length
                D = math.sin(current_angle) * ray_length
                dot = A * C + B * D
                len_sq = C * C + D * D
                param = -1
                if len_sq != 0:
                    param = dot / len_sq
                if param < 0:
                    xx, yy = self.boss_x, self.boss_y
                elif param > 1:
                    xx = self.boss_x + C
                    yy = self.boss_y + D
                else:
                    xx = self.boss_x + param * C
                    yy = self.boss_y + param * D
                distance = math.sqrt((self.player_x - xx) ** 2 + (self.player_y - yy) ** 2)
                if distance < player_radius + self.boss_size:
                    self.player_hp -= 6
                    self.player_invulnerable = True
                    self.player_invulnerable_timer = 60

    def update_hand_animations(self):
        for hand in self.hands:
            if hand["attacking"] and not self.death_phase_active:
                hand["animation_timer"] += 1
                if hand["animation_timer"] >= 5:
                    hand["animation_timer"] = 0
                    hand["animation_frame"] = 1 - hand["animation_frame"]

    def create_explosion(self, x, y):
        explosion_sprite = AnimatedSprite(x, y, scale=1.4)
        try:
            textures = []
            for i in range(1, 12):
                texture = arcade.load_texture(f"assets/effects/explosion/{i}.png")
                textures.append(texture)
            explosion_sprite.textures = {"explode": textures}
            explosion_sprite.sprite.texture = textures[0]
        except:
            explosion_colors = [(255, 200, 0), (255, 150, 0), (255, 100, 0), (255, 50, 0), (200, 0, 0), (150, 0, 0)]
            explosion_sprite.textures = {"explode": []}
            for i in range(11):
                if i < 6:
                    color = explosion_colors[i]
                else:
                    color = explosion_colors[11 - i - 1]
                img = Image.new('RGBA', (64, 64), color + (255,))
                texture = arcade.Texture.create_empty(f"{i}", (64, 64))
                texture.image = img
                explosion_sprite.textures["explode"].append(texture)

        explosion_sprite.set_state("explode")
        self.explosions.append({
            "sprite": explosion_sprite,
            "x": x,
            "y": y,
            "timer": 0,
            "active": True,
            "damage_applied": False
        })

    def update_special_phase(self):
        if self.death_phase_active:
            self.danger_point_timer += 1
            if self.danger_point_timer >= self.danger_point_interval:
                self.danger_point_timer = 0
                for _ in range(2):
                    warning_x = random.randint(50, SCREEN_WIDTH - 50)
                    warning_y = random.randint(50, SCREEN_HEIGHT - 50)
                    self.danger_point_warnings.append({
                        "x": warning_x,
                        "y": warning_y,
                        "size": 40,
                        "timer": self.warning_duration,
                        "active": True
                    })
        else:
            self.danger_point_timer += 1
            if self.danger_point_timer >= self.danger_point_interval:
                self.danger_point_timer = 0
                warning_x = random.randint(50, SCREEN_WIDTH - 50)
                warning_y = random.randint(50, SCREEN_HEIGHT - 50)
                self.danger_point_warnings.append({
                    "x": warning_x,
                    "y": warning_y,
                    "size": 40,
                    "timer": self.warning_duration,
                    "active": True
                })

        for warning in self.danger_point_warnings[:]:
            if warning["active"]:
                warning["timer"] -= 1
                if warning["timer"] <= 0:
                    warning["active"] = False
                    self.create_explosion(warning["x"], warning["y"])

        self.danger_point_warnings = [w for w in self.danger_point_warnings if w["active"]]

        for explosion in self.explosions[:]:
            explosion["timer"] += 1

            explosion["sprite"].x = explosion["x"]
            explosion["sprite"].y = explosion["y"]
            explosion["sprite"].update_animation(1 / 60)

            if not explosion["damage_applied"] and not self.player_invulnerable:
                distance = math.sqrt((self.player_x - explosion["x"]) ** 2 + (self.player_y - explosion["y"]) ** 2)
                if distance < 60:
                    self.player_hp -= 30
                    self.player_invulnerable = True
                    self.player_invulnerable_timer = 60
                    explosion["damage_applied"] = True

            if explosion["timer"] > 66:
                explosion["active"] = False
                self.explosions.remove(explosion)

    def on_update(self, delta_time):
        if self.game_paused or self.game_ended:
            return

        if self.player_hp <= 0 and not self.defeat_music_played:
            self.play_defeat_music()
        elif self.victory_achieved and not self.victory_music_played:
            self.play_victory_music()

        if self.death_phase_active:
            self.special_phase_duration += 1
            if self.special_phase_duration >= self.special_phase_max_duration:
                self.victory_achieved = True
                self.game_ended = True
                if not self.final_time:
                    self.final_time = datetime.now() - self.start_time
                return

        if self.player_hp <= 0:
            if not self.final_time:
                self.final_time = datetime.now() - self.start_time
                self.game_ended = True
            return

        if self.player_invulnerable:
            self.player_invulnerable_timer -= 1
            if self.player_invulnerable_timer <= 0:
                self.player_invulnerable = False

        self.player_sprite.update_animation(delta_time)
        if self.player_attacking:
            self.player_attack_frame += 1
            if self.player_attack_frame >= 15 and not self.player_damage_dealt:
                self.apply_player_damage()
            if self.player_attack_frame >= 30:
                self.player_attacking = False
                self.player_attack_frame = 0
                self.player_damage_dealt = False
                face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
                self.player_sprite.set_state("idle", face_right)

        if not self.boss_invulnerable:
            self.boss_sprite.set_state("idle")
            self.boss_sprite.update_animation(delta_time)
        else:
            if self.boss_sprite.current_state == "damage":
                self.boss_sprite.update_animation(delta_time)

        move_x = 0
        move_y = 0
        if not self.player_attacking:
            if self.up_pressed:
                move_y += self.player_speed
            if self.down_pressed:
                move_y -= self.player_speed
            if self.left_pressed:
                move_x -= self.player_speed
            if self.right_pressed:
                move_x += self.player_speed

        if move_x != 0 or move_y != 0:
            self.player_x += move_x
            self.player_y += move_y
            if move_x != 0 and not self.player_attacking:
                self.player_sprite.set_state("run", move_x > 0)
            elif not self.player_attacking:
                face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
                self.player_sprite.set_state("run", face_right)
        elif not self.player_attacking and self.player_attack_frame == 0:
            face_right = self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right)
            self.player_sprite.set_state("idle", face_right)

        self.player_x = max(20, min(SCREEN_WIDTH - 20, self.player_x))
        self.player_y = max(20, min(SCREEN_HEIGHT - 20, self.player_y))

        if not self.death_phase_active:
            self.update_hand_positions()
            self.update_hand_animations()
            self.check_hand_collision()

        if self.death_phase_active:
            self.update_special_phase()
        elif self.attack_phase == "special_phase":
            self.special_phase_duration += 1
            self.update_special_phase()
            if self.special_phase_duration >= self.special_phase_max_duration:
                self.attack_phase = "idle"
                self.boss_invulnerable = False
                self.danger_point_warnings = []
                self.danger_points = []
                self.explosions = []
                self.special_phase_duration = 0
                self.attack_counter = 0
                self.boss_sprite.set_state("idle")
                self.danger_point_interval = 30

        if not self.death_phase_active:
            if self.attack_phase == "idle":
                self.attack_timer += 1
                if self.attack_timer >= self.attack_interval:
                    self.start_attack()
                    self.attack_timer = 0
            elif self.attack_phase == "moving":
                self.attack_duration += 1
                self.update_hand_positions()
                if self.attack_duration >= 120:
                    for hand in self.hands:
                        hand["angle"] = hand["target_angle"]
                        hand["current_angle"] = hand["target_angle"]
                    self.attack_phase = "warning"
                    self.attack_duration = 60
            elif self.attack_phase == "warning":
                self.attack_duration -= 1
                self.update_hand_positions()
                if self.attack_duration <= 0:
                    self.attack_phase = "attacking"
                    for hand in self.hands:
                        hand["attacking"] = True
                        hand["attack_timer"] = 60
                        hand["show_preview"] = False
            elif self.attack_phase == "attacking":
                self.check_hand_collisions()
                self.update_hand_positions()

                all_done = True
                for hand in self.hands:
                    if hand["attack_timer"] > 0:
                        hand["attack_timer"] -= 1
                        all_done = False
                    else:
                        hand["attacking"] = False
                        hand["animation_frame"] = 0

                if all_done:
                    self.attack_phase = "idle"
                    self.attack_counter += 1
                    self.attack_timer = 0
                    if self.attack_counter >= self.special_phase_after_attacks:
                        self.start_special_phase()
            elif self.attack_phase == "special_warning":
                self.attack_duration -= 1
                if self.attack_duration <= 0:
                    self.attack_phase = "special_phase"
                    self.special_phase_duration = 0

    def return_to_main_menu(self):
        self.stop_music()
        self.close()
        menu = MainMenu()
        menu.center_window()
        arcade.run()


def main():
    menu = MainMenu()
    menu.center_window()
    arcade.run()


if __name__ == "__main__":
    main()
