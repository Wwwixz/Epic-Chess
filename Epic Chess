import arcade
import math
import random
from arcade.gui import UIManager, UIAnchorLayout, UIBoxLayout, UIFlatButton
from datetime import datetime

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
SCREEN_TITLE = "Epic Chess"


class AnimatedSprite:
    def __init__(self, x, y, scale=1.0):
        self.x = x
        self.y = y
        self.scale = scale
        self.sprite = None
        self.current_state = "idle"
        self.facing_right = True
        self.textures = {}
        self.animation_speed = 0.1
        self.time_since_last_frame = 0
        self.current_frame = 0

    def load_textures(self, base_path, states_dict):
        for state, frame_count in states_dict.items():
            state_textures = []
            for i in range(1, frame_count + 1):
                try:
                    texture_path = f"{base_path}/{state}/{i}.png"
                    texture = arcade.load_texture(texture_path)
                    print(f"Загружена текстура: {texture_path}")
                except Exception as e:
                    print(f"Не удалось загрузить текстуру {base_path}/{state}/{i}.png: {e}")
                    if "player" in base_path:
                        color = (0, 200, 0) if state == "idle" else (0, 255, 0) if state == "run" else (255, 255, 0)
                    elif "monster" in base_path:
                        color = (200, 0, 0) if state == "idle" else (255, 0, 0) if state == "run" else (255, 100, 0)
                    elif "boss" in base_path:
                        color = (150, 0, 0) if state == "idle" else (200, 0, 0) if state == "damage" else (255, 0, 0)
                    else:
                        color = (100, 100, 100)
                    texture = arcade.Texture.create_filled(f"{state}_{i}", (64, 64), color)
                state_textures.append(texture)
            self.textures[state] = state_textures

        if "idle" in self.textures and self.textures["idle"]:
            initial_texture = self.textures["idle"][0]
            self.sprite = arcade.Sprite(center_x=self.x, center_y=self.y, scale=self.scale)
            self.sprite.texture = initial_texture
            print(f"Создан спрайт с текстурой: {initial_texture}")

    def update_animation(self, delta_time):
        if self.sprite is None or self.current_state not in self.textures:
            return

        textures = self.textures[self.current_state]
        if not textures:
            return

        self.time_since_last_frame += delta_time

        if self.time_since_last_frame >= self.animation_speed:
            self.time_since_last_frame = 0
            self.current_frame = (self.current_frame + 1) % len(textures)

            texture = textures[self.current_frame]
            if not self.facing_right:
                texture = texture.flip_horizontally()

            self.sprite.texture = texture

    def set_state(self, state, face_right=True):
        if state != self.current_state and state in self.textures:
            self.current_state = state
            self.current_frame = 0
            self.facing_right = face_right

            if self.textures[state]:
                texture = self.textures[state][0]
                if not self.facing_right:
                    texture = texture.flip_horizontally()
                if self.sprite:
                    self.sprite.texture = texture

    def draw(self):
        if self.sprite:
            self.sprite.center_x = self.x
            self.sprite.center_y = self.y
            self.sprite.draw()
        else:
            arcade.draw_circle_filled(self.x, self.y, 20, arcade.color.BLUE)


class Explosion:
    def __init__(self, x, y, scale=1.0):
        self.x = x
        self.y = y
        self.scale = scale
        self.active = True
        self.current_frame = 0
        self.time_since_last_frame = 0
        self.animation_speed = 0.05
        self.textures = []
        self.sprite = None

    def load_textures(self, frame_count=11):
        self.textures = []
        for i in range(1, frame_count + 1):
            try:
                texture = arcade.load_texture(f"assets/sprites/effects/explosion/{i}.png")
                print(f"Загружена текстура взрыва: assets/sprites/effects/explosion/{i}.png")
            except Exception as e:
                print(f"Не удалось загрузить текстуру взрыва {i}: {e}")
                color = (255, 100 + i * 20, 50)
                texture = arcade.Texture.create_filled(f"explosion_{i}", (128, 128), color)
            self.textures.append(texture)

        if self.textures:
            self.sprite = arcade.Sprite(center_x=self.x, center_y=self.y, scale=self.scale)
            self.sprite.texture = self.textures[0]

    def update(self, delta_time):
        if not self.active or not self.sprite or not self.textures:
            return

        self.time_since_last_frame += delta_time

        if self.time_since_last_frame >= self.animation_speed:
            self.time_since_last_frame = 0
            self.current_frame += 1

            if self.current_frame >= len(self.textures):
                self.active = False
            else:
                self.sprite.texture = self.textures[self.current_frame]

    def draw(self):
        if self.active and self.sprite:
            self.sprite.center_x = self.x
            self.sprite.center_y = self.y
            self.sprite.draw()
        elif self.active:
            pulse = 20 + 10 * math.sin(self.time_since_last_frame * 10)
            arcade.draw_circle_filled(self.x, self.y, pulse, arcade.color.ORANGE)


class MainMenu(arcade.Window):
    def __init__(self):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)

        self.manager = UIManager()
        self.manager.enable()

        self.anchor_layout = UIAnchorLayout()
        self.box_layout = UIBoxLayout(vertical=True, space_between=10)

        self.setup_widgets()

        self.anchor_layout.add(self.box_layout)
        self.manager.add(self.anchor_layout)

        self.game_start_time = None

    def setup_widgets(self):
        start_button = UIFlatButton(text="Играть", width=200, height=50)
        start_button.on_click = self.on_start_click

        exit_button = UIFlatButton(text="Выход", width=200, height=50)
        exit_button.on_click = self.on_exit_click

        self.box_layout.add(start_button)
        self.box_layout.add(exit_button)

    def on_start_click(self, event):
        self.close()
        self.game_start_time = datetime.now()
        game = Level1(self.game_start_time)
        game.center_window()
        game.setup()
        arcade.run()

    def on_exit_click(self, event):
        arcade.close_window()

    def on_draw(self):
        self.clear()

        arcade.draw_text("EPIC CHESS", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 80, arcade.color.DARK_BLUE,
                         48, anchor_x="center", bold=True)

        arcade.draw_text("Управление в игре:", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 110, arcade.color.DARK_GRAY,
                         24, anchor_x="center")

        arcade.draw_text("Стрелки - движение", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 150, arcade.color.DARK_GRAY,
                         18, anchor_x="center")

        arcade.draw_text("Пробел - атака", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 170, arcade.color.DARK_GRAY,
                         18, anchor_x="center")

        arcade.draw_text("R - рестарт, ESC - выход", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 190, arcade.color.DARK_GRAY,
                         18, anchor_x="center")

        self.manager.draw()


class Level1(arcade.Window):
    def __init__(self, start_time):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)

        self.start_time = start_time
        self.final_time = None
        self.game_paused = False
        self.game_ended = False
        self.level = 1
        self.background_sprite = None

        try:
            background_texture = arcade.load_texture("assets/backgrounds/level1.png")
            self.background_sprite = arcade.Sprite()
            self.background_sprite.texture = background_texture
            self.background_sprite.center_x = SCREEN_WIDTH // 2
            self.background_sprite.center_y = SCREEN_HEIGHT // 2
            self.background_sprite.width = SCREEN_WIDTH
            self.background_sprite.height = SCREEN_HEIGHT
            print("Загружен фон для уровня 1")
        except:
            print("Не удалось загрузить фон для уровня 1")

        self.player_x = 400
        self.player_y = 300
        self.player_speed = 8
        self.player_hp = 100
        self.player_max_hp = 100
        self.player_attack_cooldown = 0

        self.player_sprite = AnimatedSprite(self.player_x, self.player_y, scale=1.0)
        
        self.monsters = []
        self.total_monsters = 4

        monster_positions = [(200, 300), (600, 300), (400, 100), (400, 500)]
        for pos in monster_positions:
            monster = {
                "x": pos[0],
                "y": pos[1],
                "alive": True,
                "hp": 80,
                "max_hp": 80,
                "attack_timer": 0,
                "sprite": AnimatedSprite(pos[0], pos[1], scale=0.8)
            }
            self.monsters.append(monster)

        self.teleport_active = False
        self.teleport_x = 100
        self.teleport_y = 100
        self.teleport_size = 40
        self.teleport_animation = 0

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

        self.chits_1 = False
        self.hart = 15

        self.kills = 0
        self.frame_count = 0

    def setup(self):
        self.player_sprite.load_textures("assets/sprites/player", {
            "idle": 1,
            "run": 8,
            "attack": 6
        })
        
        for monster in self.monsters:
            monster["sprite"].load_textures("assets/sprites/monsters/level1", {
                "idle": 1,
                "run": 6,
                "attack": 4
            })

    def on_draw(self):
        self.clear()

        if self.background_sprite:
            self.background_sprite.draw()
        else:
            arcade.set_background_color(arcade.color.LIGHT_GRAY)

        for monster in self.monsters:
            if monster["alive"]:
                monster["sprite"].draw()

                if monster["hp"] < monster["max_hp"]:
                    hp_width = 40 * (monster["hp"] / monster["max_hp"])
                    hp_points = [
                        (monster["x"] - 20, monster["y"] + 40 - 2.5),
                        (monster["x"] - 20 + hp_width, monster["y"] + 40 - 2.5),
                        (monster["x"] - 20 + hp_width, monster["y"] + 40 + 2.5),
                        (monster["x"] - 20, monster["y"] + 40 + 2.5),
                    ]
                    arcade.draw_polygon_filled(hp_points, arcade.color.GREEN)
                    border_points = [
                        (monster["x"] - 20, monster["y"] + 40 - 2.5),
                        (monster["x"] + 20, monster["y"] + 40 - 2.5),
                        (monster["x"] + 20, monster["y"] + 40 + 2.5),
                        (monster["x"] - 20, monster["y"] + 40 + 2.5),
                    ]
                    arcade.draw_polygon_outline(border_points, arcade.color.BLACK, 1)

        self.player_sprite.draw()

        if self.teleport_active:
            self.teleport_animation += 1
            pulse = abs(20 * (self.teleport_animation % 60 - 30) / 30)

            arcade.draw_circle_filled(self.teleport_x, self.teleport_y, self.teleport_size + pulse,
                                      arcade.color.PURPLE)
            arcade.draw_circle_outline(self.teleport_x, self.teleport_y, self.teleport_size + pulse + 5,
                                       arcade.color.BLACK, 3)

            for i in range(8):
                angle = self.teleport_animation * 0.1 + i * math.pi / 4
                x1 = self.teleport_x + (self.teleport_size + pulse) * math.cos(angle)
                y1 = self.teleport_y + (self.teleport_size + pulse) * math.sin(angle)
                x2 = self.teleport_x + (self.teleport_size + pulse + 15) * math.cos(angle)
                y2 = self.teleport_y + (self.teleport_size + pulse + 15) * math.sin(angle)
                arcade.draw_line(x1, y1, x2, y2, arcade.color.YELLOW, 3)

        hp_width = 200 * (self.player_hp / self.player_max_hp)
        hp_points = [
            (20, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 20),
            (20, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_filled(hp_points, arcade.color.RED)
        hp_border_points = [
            (20, SCREEN_HEIGHT - 40),
            (220, SCREEN_HEIGHT - 40),
            (220, SCREEN_HEIGHT - 20),
            (20, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_outline(hp_border_points, arcade.color.BLACK, 2)

        if not self.game_ended:
            current_time = datetime.now()
            elapsed = current_time - self.start_time
            elapsed_str = str(elapsed).split('.')[0]
        else:
            if self.final_time:
                elapsed_str = str(self.final_time).split('.')[0]
            else:
                elapsed_str = "00:00:00"

        arcade.draw_text(f"Время: {elapsed_str}", 20, SCREEN_HEIGHT - 220, arcade.color.BLACK, 16)
        arcade.draw_text(f"HP: {int(self.player_hp)}/{self.player_max_hp}", 20, SCREEN_HEIGHT - 60,
                         arcade.color.BLACK, 18)
        arcade.draw_text(f"Убито: {self.kills}/{self.total_monsters}", 20, SCREEN_HEIGHT - 90,
                         arcade.color.BLACK, 18)
        arcade.draw_text(f"Уровень: {self.level}", 20, SCREEN_HEIGHT - 115,
                         arcade.color.BLACK, 18)

        if self.teleport_active:
            arcade.draw_text("Подойдите к телепорту", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 40,
                             arcade.color.PURPLE, 24, anchor_x="center")

        if self.player_hp <= 0:
            game_over_points = [
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 60),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 - 60),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 + 60),
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 60),
            ]
            arcade.draw_polygon_filled(game_over_points, arcade.color.BLACK)
            arcade.draw_polygon_outline(game_over_points, arcade.color.WHITE, 2)
            
            arcade.draw_text("ВЫ ПРОИГРАЛИ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20,
                             arcade.color.RED, 36, anchor_x="center")
            arcade.draw_text(f"Убито монстров: {self.kills}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20,
                             arcade.color.WHITE, 24, anchor_x="center")
            arcade.draw_text(f"Время: {elapsed_str}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 45,
                             arcade.color.WHITE, 20, anchor_x="center")
            arcade.draw_text("R - начать заново", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 70,
                             arcade.color.YELLOW, 20, anchor_x="center")

        if self.game_paused:
            pause_points = [
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 80),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 - 80),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 + 80),
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 80),
            ]
            arcade.draw_polygon_filled(pause_points, (0, 0, 0, 200))
            arcade.draw_polygon_outline(pause_points, arcade.color.YELLOW, 2)
            
            arcade.draw_text("ИГРА ПРИОСТАНОВЛЕНА", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30,
                             arcade.color.WHITE, 32, anchor_x="center")
            arcade.draw_text("P - продолжить", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30,
                             arcade.color.YELLOW, 24, anchor_x="center")

    def on_key_press(self, key, modifiers):
        if key == arcade.key.P:
            self.game_paused = not self.game_paused
            return

        if key == arcade.key.C:
            self.chits_1 = not self.chits_1
            self.hart = 75 if self.chits_1 else 15
            return

        if self.game_paused:
            return

        if self.player_hp <= 0:
            if key == arcade.key.R:
                self.restart_game()
            return

        if key == arcade.key.UP:
            self.up_pressed = True
        elif key == arcade.key.DOWN:
            self.down_pressed = True
        elif key == arcade.key.LEFT:
            self.left_pressed = True
        elif key == arcade.key.RIGHT:
            self.right_pressed = True
        elif key == arcade.key.SPACE:
            self.player_attack()
        elif key == arcade.key.R:
            self.restart_game()
        elif key == arcade.key.ESCAPE:
            arcade.close_window()

    def on_key_release(self, key, modifiers):
        if self.game_paused:
            return

        if key == arcade.key.UP:
            self.up_pressed = False
        elif key == arcade.key.DOWN:
            self.down_pressed = False
        elif key == arcade.key.LEFT:
            self.left_pressed = False
        elif key == arcade.key.RIGHT:
            self.right_pressed = False

    def player_attack(self):
        if self.player_attack_cooldown > 0:
            return

        attack_range = 60
        self.player_sprite.set_state("attack",
                                     self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right))
        self.player_attack_cooldown = 15

        for monster in self.monsters:
            if not monster["alive"]:
                continue

            distance_x = abs(self.player_x - monster["x"])
            distance_y = abs(self.player_y - monster["y"])

            if distance_x < attack_range and distance_y < attack_range:
                monster["hp"] -= self.hart
                monster["sprite"].set_state("attack")
                if monster["hp"] <= 0:
                    monster["alive"] = False
                    self.kills += 1
                    self.check_teleport_spawn()

    def check_teleport_spawn(self):
        all_dead = all(not monster["alive"] for monster in self.monsters)
        if all_dead and not self.teleport_active:
            self.spawn_teleport()

    def spawn_teleport(self):
        possible_locations = [
            (100, 100),
            (SCREEN_WIDTH - 100, 100),
            (100, SCREEN_HEIGHT - 100),
            (SCREEN_WIDTH - 100, SCREEN_HEIGHT - 100),
        ]

        self.teleport_x, self.teleport_y = random.choice(possible_locations)
        self.teleport_active = True
        self.teleport_animation = 0

    def update_monsters(self):
        move_speed = 2
        min_distance = 50

        for i, monster in enumerate(self.monsters):
            if not monster["alive"]:
                continue

            target_x = self.player_x
            target_y = self.player_y

            for j, other in enumerate(self.monsters):
                if i == j or not other["alive"]:
                    continue

                dx = monster["x"] - other["x"]
                dy = monster["y"] - other["y"]
                distance = (dx ** 2 + dy ** 2) ** 0.5

                if distance < min_distance:
                    if distance == 0:
                        distance = 0.001
                    repel_force = (min_distance - distance) / min_distance
                    target_x += dx / distance * repel_force * 50
                    target_y += dy / distance * repel_force * 50

            dx = target_x - monster["x"]

            if abs(dx) > 0.5:
                monster["sprite"].set_state("run", dx > 0)
            elif monster["sprite"].current_state == "attack" and monster["attack_timer"] <= 0:
                monster["sprite"].set_state("idle", monster["sprite"].facing_right)

            if monster["x"] < target_x:
                monster["x"] += move_speed
            elif monster["x"] > target_x:
                monster["x"] -= move_speed

            if monster["y"] < target_y:
                monster["y"] += move_speed
            elif monster["y"] > target_y:
                monster["y"] -= move_speed

            monster["x"] = max(20, min(SCREEN_WIDTH - 20, monster["x"]))
            monster["y"] = max(20, min(SCREEN_HEIGHT - 20, monster["y"]))

            if monster["attack_timer"] <= 0 and self.player_hp > 0:
                distance_x = abs(self.player_x - monster["x"])
                distance_y = abs(self.player_y - monster["y"])

                if distance_x < 50 and distance_y < 50:
                    self.player_hp -= 5
                    monster["attack_timer"] = 90
                    monster["sprite"].set_state("attack")

            if monster["attack_timer"] > 0:
                monster["attack_timer"] -= 1

    def on_update(self, delta_time):
        if self.game_paused or self.game_ended:
            return

        self.frame_count += 1

        if self.player_hp <= 0:
            if not self.final_time:
                self.final_time = datetime.now() - self.start_time
                self.game_ended = True
            return

        self.player_sprite.update_animation(delta_time)

        if self.player_attack_cooldown > 0:
            self.player_attack_cooldown -= 1
            if self.player_attack_cooldown == 0:
                self.player_sprite.set_state("idle", self.player_sprite.facing_right)

        move_x = 0
        move_y = 0

        if self.up_pressed:
            move_y += self.player_speed
        if self.down_pressed:
            move_y -= self.player_speed
        if self.left_pressed:
            move_x -= self.player_speed
        if self.right_pressed:
            move_x += self.player_speed

        if move_x != 0 or move_y != 0:
            self.player_x += move_x
            self.player_y += move_y

            if move_x != 0:
                self.player_sprite.set_state("run", move_x > 0)
            else:
                self.player_sprite.set_state("run", self.player_sprite.facing_right)
        elif self.player_attack_cooldown == 0:
            self.player_sprite.set_state("idle", self.player_sprite.facing_right)

        self.player_x = max(20, min(SCREEN_WIDTH - 20, self.player_x))
        self.player_y = max(20, min(SCREEN_HEIGHT - 20, self.player_y))

        for monster in self.monsters:
            if monster["alive"]:
                monster["sprite"].update_animation(delta_time)

        if not self.teleport_active:
            self.update_monsters()
        else:
            distance_to_teleport = ((self.player_x - self.teleport_x) ** 2 +
                                    (self.player_y - self.teleport_y) ** 2) ** 0.5
            if distance_to_teleport < self.teleport_size + 20:
                self.go_to_level2()

    def go_to_level2(self):
        self.final_time = datetime.now() - self.start_time
        self.game_ended = True
        self.close()
        level2 = Level2(self.start_time)
        level2.center_window()
        level2.setup()
        arcade.run()

    def restart_game(self):
        self.game_ended = False
        self.game_paused = False
        self.start_time = datetime.now()
        self.final_time = None
        self.player_x = 400
        self.player_y = 300
        self.player_hp = 100
        self.player_attack_cooldown = 0
        self.kills = 0
        self.frame_count = 0
        self.teleport_active = False
        self.teleport_animation = 0

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

        self.player_sprite.set_state("idle", True)

        if self.background_sprite:
            try:
                background_texture = arcade.load_texture("assets/backgrounds/level1.png")
                self.background_sprite.texture = background_texture
            except:
                pass

        self.monsters = []
        monster_positions = [(200, 300), (600, 300), (400, 100), (400, 500)]
        for pos in monster_positions:
            monster = {
                "x": pos[0],
                "y": pos[1],
                "alive": True,
                "hp": 80,
                "max_hp": 80,
                "attack_timer": 0,
                "sprite": AnimatedSprite(pos[0], pos[1], scale=0.8)
            }
            monster["sprite"].load_textures("assets/sprites/monsters/level1", {
                "idle": 1,
                "run": 6,
                "attack": 4
            })
            self.monsters.append(monster)


class Level2(arcade.Window):
    def __init__(self, start_time):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)

        self.start_time = start_time
        self.final_time = None
        self.game_paused = False
        self.game_ended = False
        self.level = 2
        self.background_sprite = None

        try:
            background_texture = arcade.load_texture("assets/backgrounds/level2.png")
            self.background_sprite = arcade.Sprite()
            self.background_sprite.texture = background_texture
            self.background_sprite.center_x = SCREEN_WIDTH // 2
            self.background_sprite.center_y = SCREEN_HEIGHT // 2
            self.background_sprite.width = SCREEN_WIDTH
            self.background_sprite.height = SCREEN_HEIGHT
            print("Загружен фон для уровня 2")
        except:
            print("Не удалось загрузить фон для уровня 2")

        self.player_x = 400
        self.player_y = 300
        self.player_speed = 8
        self.player_hp = 100
        self.player_max_hp = 100
        self.player_attack_cooldown = 0

        self.player_sprite = AnimatedSprite(self.player_x, self.player_y, scale=1.0)
        
        self.chits_1 = False
        self.hart = 15

        self.monsters = []
        self.total_monsters = 5

        monster_positions = [
            (150, 150), (650, 150), (150, 450), (650, 450), (400, 300)
        ]
        monster_sizes = [30, 30, 30, 30, 35]
        monster_hps = [120, 120, 120, 120, 150]

        for i, pos in enumerate(monster_positions):
            monster = {
                "x": pos[0],
                "y": pos[1],
                "alive": True,
                "hp": monster_hps[i],
                "max_hp": monster_hps[i],
                "attack_timer": 0,
                "size": monster_sizes[i],
                "sprite": AnimatedSprite(pos[0], pos[1], scale=0.9 if i < 4 else 1.0)
            }
            self.monsters.append(monster)

        self.teleport_active = False
        self.teleport_x = 100
        self.teleport_y = 100
        self.teleport_size = 40
        self.teleport_animation = 0

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

        self.kills = 0
        self.frame_count = 0

    def setup(self):
        self.player_sprite.load_textures("assets/sprites/player", {
            "idle": 1,
            "run": 8,
            "attack": 6
        })
        
        for monster in self.monsters:
            monster["sprite"].load_textures("assets/sprites/monsters/level2", {
                "idle": 1,
                "run": 6,
                "attack": 4
            })

    def on_draw(self):
        self.clear()

        if self.background_sprite:
            self.background_sprite.draw()
        else:
            arcade.set_background_color(arcade.color.DARK_SLATE_GRAY)

        for monster in self.monsters:
            if monster["alive"]:
                monster["sprite"].draw()

                if monster["hp"] < monster["max_hp"]:
                    hp_width = monster["size"] * (monster["hp"] / monster["max_hp"])
                    hp_points = [
                        (monster["x"] - monster["size"] / 2, monster["y"] + monster["size"] + 15 - 2.5),
                        (monster["x"] - monster["size"] / 2 + hp_width, monster["y"] + monster["size"] + 15 - 2.5),
                        (monster["x"] - monster["size"] / 2 + hp_width, monster["y"] + monster["size"] + 15 + 2.5),
                        (monster["x"] - monster["size"] / 2, monster["y"] + monster["size"] + 15 + 2.5),
                    ]
                    arcade.draw_polygon_filled(hp_points, arcade.color.GREEN)
                    border_points = [
                        (monster["x"] - monster["size"] / 2, monster["y"] + monster["size"] + 15 - 2.5),
                        (monster["x"] + monster["size"] / 2, monster["y"] + monster["size"] + 15 - 2.5),
                        (monster["x"] + monster["size"] / 2, monster["y"] + monster["size"] + 15 + 2.5),
                        (monster["x"] - monster["size"] / 2, monster["y"] + monster["size"] + 15 + 2.5),
                    ]
                    arcade.draw_polygon_outline(border_points, arcade.color.BLACK, 1)

        self.player_sprite.draw()

        if self.teleport_active:
            self.teleport_animation += 1
            pulse = abs(20 * (self.teleport_animation % 60 - 30) / 30)

            arcade.draw_circle_filled(self.teleport_x, self.teleport_y, self.teleport_size + pulse,
                                      arcade.color.PURPLE)
            arcade.draw_circle_outline(self.teleport_x, self.teleport_y, self.teleport_size + pulse + 5,
                                       arcade.color.BLACK, 3)

            for i in range(8):
                angle = self.teleport_animation * 0.1 + i * math.pi / 4
                x1 = self.teleport_x + (self.teleport_size + pulse) * math.cos(angle)
                y1 = self.teleport_y + (self.teleport_size + pulse) * math.sin(angle)
                x2 = self.teleport_x + (self.teleport_size + pulse + 15) * math.cos(angle)
                y2 = self.teleport_y + (self.teleport_size + pulse + 15) * math.sin(angle)
                arcade.draw_line(x1, y1, x2, y2, arcade.color.YELLOW, 3)

        hp_width = 200 * (self.player_hp / self.player_max_hp)
        hp_points = [
            (20, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 20),
            (20, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_filled(hp_points, arcade.color.RED)
        hp_border_points = [
            (20, SCREEN_HEIGHT - 40),
            (220, SCREEN_HEIGHT - 40),
            (220, SCREEN_HEIGHT - 20),
            (20, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_outline(hp_border_points, arcade.color.BLACK, 2)

        if not self.game_ended:
            current_time = datetime.now()
            elapsed = current_time - self.start_time
            elapsed_str = str(elapsed).split('.')[0]
        else:
            if self.final_time:
                elapsed_str = str(self.final_time).split('.')[0]
            else:
                elapsed_str = "00:00:00"

        arcade.draw_text(f"Время: {elapsed_str}", 20, SCREEN_HEIGHT - 220, arcade.color.WHITE, 16)
        arcade.draw_text(f"HP: {int(self.player_hp)}/{self.player_max_hp}", 20, SCREEN_HEIGHT - 60,
                         arcade.color.WHITE, 18)
        arcade.draw_text(f"Убито: {self.kills}/{self.total_monsters}", 20, SCREEN_HEIGHT - 90,
                         arcade.color.WHITE, 18)
        arcade.draw_text(f"Уровень: {self.level}", 20, SCREEN_HEIGHT - 115,
                         arcade.color.WHITE, 18)

        if self.teleport_active:
            arcade.draw_text("Подойдите к телепорту", SCREEN_WIDTH // 2, SCREEN_HEIGHT - 40,
                             arcade.color.PURPLE, 24, anchor_x="center")

        if self.player_hp <= 0:
            game_over_points = [
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 60),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 - 60),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 + 60),
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 60),
            ]
            arcade.draw_polygon_filled(game_over_points, arcade.color.BLACK)
            arcade.draw_polygon_outline(game_over_points, arcade.color.WHITE, 2)
            
            arcade.draw_text("ВЫ ПРОИГРАЛИ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20,
                             arcade.color.RED, 36, anchor_x="center")
            arcade.draw_text(f"Убито монстров: {self.kills}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20,
                             arcade.color.WHITE, 24, anchor_x="center")
            arcade.draw_text(f"Время: {elapsed_str}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 45,
                             arcade.color.WHITE, 20, anchor_x="center")
            arcade.draw_text("R - начать заново", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 70,
                             arcade.color.YELLOW, 20, anchor_x="center")

        if self.game_paused:
            pause_points = [
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 80),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 - 80),
                (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 + 80),
                (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 80),
            ]
            arcade.draw_polygon_filled(pause_points, (0, 0, 0, 200))
            arcade.draw_polygon_outline(pause_points, arcade.color.YELLOW, 2)
            
            arcade.draw_text("ИГРА ПРИОСТАНОВЛЕНА", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30,
                             arcade.color.WHITE, 32, anchor_x="center")
            arcade.draw_text("P - продолжить", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30,
                             arcade.color.YELLOW, 24, anchor_x="center")

        if self.teleport_active and all(not monster["alive"] for monster in self.monsters):
            distance_to_teleport = ((self.player_x - self.teleport_x) ** 2 +
                                    (self.player_y - self.teleport_y) ** 2) ** 0.5
            if distance_to_teleport < self.teleport_size + 20:
                self.show_victory()

    def show_victory(self):
        if not self.final_time:
            self.final_time = datetime.now() - self.start_time
            self.game_ended = True

        victory_points = [
            (SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 2 - 100),
            (SCREEN_WIDTH // 2 + 250, SCREEN_HEIGHT // 2 - 100),
            (SCREEN_WIDTH // 2 + 250, SCREEN_HEIGHT // 2 + 100),
            (SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 2 + 100),
        ]
        arcade.draw_polygon_filled(victory_points, arcade.color.DARK_BLUE)
        arcade.draw_polygon_outline(victory_points, arcade.color.GOLD, 3)

        arcade.draw_text("ПОБЕДА!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50,
                         arcade.color.GOLD, 48, anchor_x="center", bold=True)
        arcade.draw_text("Нажмите SPACE для финального босса", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2,
                         arcade.color.WHITE, 28, anchor_x="center")

        if self.final_time:
            elapsed_str = str(self.final_time).split('.')[0]
        else:
            elapsed_str = "00:00:00"

        arcade.draw_text(f"Общее время: {elapsed_str}", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 40,
                         arcade.color.YELLOW, 24, anchor_x="center")
        arcade.draw_text("R - начать заново", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80,
                         arcade.color.GREEN, 22, anchor_x="center")

    def on_key_press(self, key, modifiers):
        if key == arcade.key.P:
            self.game_paused = not self.game_paused
            return

        if key == arcade.key.C:
            self.chits_1 = not self.chits_1
            self.hart = 75 if self.chits_1 else 15
            return

        if self.game_paused:
            return

        if self.player_hp <= 0 or self.game_ended:
            if key == arcade.key.R:
                self.restart_game()
            elif key == arcade.key.SPACE and self.game_ended and all(not monster["alive"] for monster in self.monsters):
                self.close()
                boss_fight = BossFight(self.start_time)
                boss_fight.center_window()
                boss_fight.setup()
                arcade.run()
            return

        if key == arcade.key.UP:
            self.up_pressed = True
        elif key == arcade.key.DOWN:
            self.down_pressed = True
        elif key == arcade.key.LEFT:
            self.left_pressed = True
        elif key == arcade.key.RIGHT:
            self.right_pressed = True
        elif key == arcade.key.SPACE:
            self.player_attack()
        elif key == arcade.key.R:
            self.restart_game()
        elif key == arcade.key.ESCAPE:
            arcade.close_window()

    def on_key_release(self, key, modifiers):
        if self.game_paused:
            return

        if key == arcade.key.UP:
            self.up_pressed = False
        elif key == arcade.key.DOWN:
            self.down_pressed = False
        elif key == arcade.key.LEFT:
            self.left_pressed = False
        elif key == arcade.key.RIGHT:
            self.right_pressed = False

    def player_attack(self):
        if self.player_attack_cooldown > 0:
            return

        attack_range = 60
        self.player_sprite.set_state("attack",
                                     self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right))
        self.player_attack_cooldown = 15

        for monster in self.monsters:
            if not monster["alive"]:
                continue

            distance_x = abs(self.player_x - monster["x"])
            distance_y = abs(self.player_y - monster["y"])

            if distance_x < attack_range and distance_y < attack_range:
                monster["hp"] -= self.hart
                monster["sprite"].set_state("attack")
                if monster["hp"] <= 0:
                    monster["alive"] = False
                    self.kills += 1
                    self.check_teleport_spawn()

    def check_teleport_spawn(self):
        all_dead = all(not monster["alive"] for monster in self.monsters)
        if all_dead and not self.teleport_active:
            self.spawn_teleport()

    def spawn_teleport(self):
        possible_locations = [
            (100, 100),
            (SCREEN_WIDTH - 100, 100),
            (100, SCREEN_HEIGHT - 100),
            (SCREEN_WIDTH - 100, SCREEN_HEIGHT - 100),
        ]

        self.teleport_x, self.teleport_y = random.choice(possible_locations)
        self.teleport_active = True
        self.teleport_animation = 0

    def update_monsters(self):
        move_speed = 2.5
        min_distance = 50

        for i, monster in enumerate(self.monsters):
            if not monster["alive"]:
                continue

            target_x = self.player_x
            target_y = self.player_y

            for j, other in enumerate(self.monsters):
                if i == j or not other["alive"]:
                    continue

                dx = monster["x"] - other["x"]
                dy = monster["y"] - other["y"]
                distance = (dx ** 2 + dy ** 2) ** 0.5

                if distance < min_distance:
                    if distance == 0:
                        distance = 0.001
                    repel_force = (min_distance - distance) / min_distance
                    target_x += dx / distance * repel_force * 50
                    target_y += dy / distance * repel_force * 50

            dx = target_x - monster["x"]

            if abs(dx) > 0.5:
                monster["sprite"].set_state("run", dx > 0)
            elif monster["sprite"].current_state == "attack" and monster["attack_timer"] <= 0:
                monster["sprite"].set_state("idle", monster["sprite"].facing_right)

            if monster["x"] < target_x:
                monster["x"] += move_speed
            elif monster["x"] > target_x:
                monster["x"] -= move_speed

            if monster["y"] < target_y:
                monster["y"] += move_speed
            elif monster["y"] > target_y:
                monster["y"] -= move_speed

            monster["x"] = max(monster["size"], min(SCREEN_WIDTH - monster["size"], monster["x"]))
            monster["y"] = max(monster["size"], min(SCREEN_HEIGHT - monster["size"], monster["y"]))

            if monster["attack_timer"] <= 0 and self.player_hp > 0:
                distance_x = abs(self.player_x - monster["x"])
                distance_y = abs(self.player_y - monster["y"])

                if distance_x < 50 and distance_y < 50:
                    self.player_hp -= 8
                    monster["attack_timer"] = 90
                    monster["sprite"].set_state("attack")

            if monster["attack_timer"] > 0:
                monster["attack_timer"] -= 1

    def on_update(self, delta_time):
        if self.game_paused or self.game_ended:
            return

        self.frame_count += 1

        if self.player_hp <= 0:
            if not self.final_time:
                self.final_time = datetime.now() - self.start_time
                self.game_ended = True
            return

        self.player_sprite.update_animation(delta_time)

        if self.player_attack_cooldown > 0:
            self.player_attack_cooldown -= 1
            if self.player_attack_cooldown == 0:
                self.player_sprite.set_state("idle", self.player_sprite.facing_right)

        move_x = 0
        move_y = 0

        if self.up_pressed:
            move_y += self.player_speed
        if self.down_pressed:
            move_y -= self.player_speed
        if self.left_pressed:
            move_x -= self.player_speed
        if self.right_pressed:
            move_x += self.player_speed

        if move_x != 0 or move_y != 0:
            self.player_x += move_x
            self.player_y += move_y

            if move_x != 0:
                self.player_sprite.set_state("run", move_x > 0)
            else:
                self.player_sprite.set_state("run", self.player_sprite.facing_right)
        elif self.player_attack_cooldown == 0:
            self.player_sprite.set_state("idle", self.player_sprite.facing_right)

        self.player_x = max(20, min(SCREEN_WIDTH - 20, self.player_x))
        self.player_y = max(20, min(SCREEN_HEIGHT - 20, self.player_y))

        for monster in self.monsters:
            if monster["alive"]:
                monster["sprite"].update_animation(delta_time)

        if not self.teleport_active:
            self.update_monsters()

    def restart_game(self):
        self.game_ended = False
        self.game_paused = False
        self.start_time = datetime.now()
        self.final_time = None
        self.player_x = 400
        self.player_y = 300
        self.player_hp = 100
        self.player_attack_cooldown = 0
        self.kills = 0
        self.frame_count = 0
        self.teleport_active = False
        self.teleport_animation = 0

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

        self.player_sprite.set_state("idle", True)

        if self.background_sprite:
            try:
                background_texture = arcade.load_texture("assets/backgrounds/level2.png")
                self.background_sprite.texture = background_texture
            except:
                pass

        self.monsters = []
        monster_positions = [
            (150, 150), (650, 150), (150, 450), (650, 450), (400, 300)
        ]
        monster_sizes = [30, 30, 30, 30, 35]
        monster_hps = [120, 120, 120, 120, 150]

        for i, pos in enumerate(monster_positions):
            monster = {
                "x": pos[0],
                "y": pos[1],
                "alive": True,
                "hp": monster_hps[i],
                "max_hp": monster_hps[i],
                "attack_timer": 0,
                "size": monster_sizes[i],
                "sprite": AnimatedSprite(pos[0], pos[1], scale=0.9 if i < 4 else 1.0)
            }
            monster["sprite"].load_textures("assets/sprites/monsters/level2", {
                "idle": 1,
                "run": 6,
                "attack": 4
            })
            self.monsters.append(monster)


class BossFight(arcade.Window):
    def __init__(self, start_time):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, "Финальный Босс - ЭКСТРЕМАЛЬНЫЙ")

        self.start_time = start_time
        self.final_time = None
        self.game_paused = False
        self.game_ended = False
        self.background_sprite = None

        try:
            background_texture = arcade.load_texture("assets/backgrounds/boss.png")
            self.background_sprite = arcade.Sprite()
            self.background_sprite.texture = background_texture
            self.background_sprite.center_x = SCREEN_WIDTH // 2
            self.background_sprite.center_y = SCREEN_HEIGHT // 2
            self.background_sprite.width = SCREEN_WIDTH
            self.background_sprite.height = SCREEN_HEIGHT
            print("Загружен фон для босса")
        except:
            print("Не удалось загрузить фон для босса")

        self.player_x = 400
        self.player_y = 100
        self.player_speed = 8
        self.player_hp = 150
        self.player_max_hp = 150
        self.player_attack_cooldown = 0

        self.player_sprite = AnimatedSprite(self.player_x, self.player_y, scale=1.0)
        self.boss_sprite = AnimatedSprite(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, scale=2.0)

        self.boss_x = SCREEN_WIDTH // 2
        self.boss_y = SCREEN_HEIGHT // 2
        self.boss_size = 40
        self.boss_hp = 500
        self.boss_max_hp = 500
        self.boss_invulnerable = False

        self.hands = []
        self.hand_length = 60
        self.hand_width = 10

        self.hand_sprites = []

        self.attack_timer = 0
        self.attack_interval = 90

        self.attack_counter = 0
        self.special_phase_after_attacks = 3
        self.attack_phase = "idle"
        self.attack_duration = 0
        self.special_phase_duration = 0
        self.special_phase_max_duration = 150

        self.danger_points = []
        self.danger_point_warnings = []
        self.explosions = []
        self.danger_point_timer = 0
        self.danger_point_interval = 10
        self.warning_duration = 45

        self.hand_sectors = [
            (1, 60), (61, 120), (121, 180),
            (181, 240), (241, 300), (301, 360)
        ]

        self.hand_contact_timers = {}

        self.hands_moving = False
        self.hands_movement_timer = 0
        self.hands_movement_duration = 90

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False

    def setup(self):
        self.player_sprite.load_textures("assets/sprites/player", {
            "idle": 1,
            "run": 8,
            "attack": 6
        })
        
        self.boss_sprite.load_textures("assets/sprites/boss/body", {
            "idle": 4,
            "damage": 3
        })
        
        for i in range(6):
            start_angle, end_angle = self.hand_sectors[i]
            angle = random.randint(start_angle, end_angle)

            hand_sprite = AnimatedSprite(0, 0, scale=1.0)
            # Используем первый спрайт руки из assets/sprites/boss/hands/
            hand_sprite.load_textures("assets/sprites/boss/hands", {
                "idle": 1
            })
            self.hand_sprites.append(hand_sprite)

            self.hands.append({
                "angle": math.radians(angle),
                "target_angle": math.radians(angle),
                "warning_timer": 0,
                "attacking": False,
                "attack_timer": 0,
                "speed_multiplier": 0.75,
                "current_angle": math.radians(angle),
                "move_progress": 0.0,
                "is_moving": False
            })

    def on_draw(self):
        self.clear()

        if self.background_sprite:
            self.background_sprite.draw()
        else:
            arcade.set_background_color(arcade.color.DARK_SLATE_GRAY)

        for warning in self.danger_point_warnings:
            if warning["active"]:
                pulse_size = warning["size"] * (warning["timer"] / self.warning_duration)
                arcade.draw_circle_filled(warning["x"], warning["y"], pulse_size, (255, 255, 0))

        for explosion in self.explosions:
            explosion.draw()

        for point in self.danger_points:
            if point["active"]:
                pulse_size = point["size"] + 8 * math.sin(point["timer"] * 0.3)
                arcade.draw_circle_filled(point["x"], point["y"], pulse_size, (255, 50, 50))

        self.boss_sprite.draw()

        if self.attack_phase != "special_phase":
            for i, hand in enumerate(self.hands):
                current_angle = hand["current_angle"]

                x = self.boss_x + math.cos(current_angle) * self.hand_length
                y = self.boss_y + math.sin(current_angle) * self.hand_length

                if i < len(self.hand_sprites):
                    hand_sprite = self.hand_sprites[i]
                    hand_sprite.x = x
                    hand_sprite.y = y
                    hand_sprite.draw()

                if hand["attacking"]:
                    x2 = x + math.cos(current_angle) * self.hand_length
                    y2 = y + math.sin(current_angle) * self.hand_length
                    arcade.draw_line(x2, y2, x2 + math.cos(current_angle) * 400,
                                     y2 + math.sin(current_angle) * 400, (255, 0, 0), 25)

        self.player_sprite.draw()

        hp_width = 200 * (self.player_hp / self.player_max_hp)
        hp_points = [
            (20, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 40),
            (20 + hp_width, SCREEN_HEIGHT - 20),
            (20, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_filled(hp_points, arcade.color.RED)
        hp_border_points = [
            (20, SCREEN_HEIGHT - 40),
            (220, SCREEN_HEIGHT - 40),
            (220, SCREEN_HEIGHT - 20),
            (20, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_outline(hp_border_points, arcade.color.BLACK, 2)

        boss_hp_width = 300 * (self.boss_hp / self.boss_max_hp)
        boss_color = arcade.color.PURPLE if self.boss_invulnerable else arcade.color.DARK_RED
        boss_hp_points = [
            (SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 40),
            (SCREEN_WIDTH // 2 - 150 + boss_hp_width, SCREEN_HEIGHT - 40),
            (SCREEN_WIDTH // 2 - 150 + boss_hp_width, SCREEN_HEIGHT - 20),
            (SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_filled(boss_hp_points, boss_color)
        boss_hp_border_points = [
            (SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 40),
            (SCREEN_WIDTH // 2 + 150, SCREEN_HEIGHT - 40),
            (SCREEN_WIDTH // 2 + 150, SCREEN_HEIGHT - 20),
            (SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT - 20),
        ]
        arcade.draw_polygon_outline(boss_hp_border_points, arcade.color.BLACK, 2)

        if not self.game_ended:
            current_time = datetime.now()
            elapsed = current_time - self.start_time
            elapsed_str = str(elapsed).split('.')[0]
        else:
            if self.final_time:
                elapsed_str = str(self.final_time).split('.')[0]
            else:
                elapsed_str = "00:00:00"

        arcade.draw_text(f"Общее время: {elapsed_str}", 20, SCREEN_HEIGHT - 220, arcade.color.WHITE, 16)
        arcade.draw_text(f"Игрок: {int(self.player_hp)}/{self.player_max_hp}", 20, SCREEN_HEIGHT - 60,
                         arcade.color.WHITE, 18)

        boss_hp_text = f"БОСС: {int(self.boss_hp)}/{self.boss_max_hp}"
        if self.boss_invulnerable:
            boss_hp_text += " (НЕУЯЗВИМ)"
        arcade.draw_text(boss_hp_text, SCREEN_WIDTH // 2, SCREEN_HEIGHT - 60, arcade.color.WHITE, 24, anchor_x="center")

        arcade.draw_text(f"Атак до особой фазы: {self.special_phase_after_attacks - self.attack_counter}",
                         SCREEN_WIDTH // 2, SCREEN_HEIGHT - 90, arcade.color.CYAN, 16, anchor_x="center")

        if self.attack_phase == "moving":
            time_left = self.hands_movement_duration - self.hands_movement_timer
            arcade.draw_text(f"Руки двигаются! Приготовьтесь! Осталось: {time_left / 60:.1f} сек",
                             SCREEN_WIDTH // 2, 100, arcade.color.ORANGE, 20, anchor_x="center")
        elif self.attack_phase == "warning":
            arcade.draw_text("ВНИМАНИЕ! Сейчас будет выстрел!", SCREEN_WIDTH // 2, 100, arcade.color.YELLOW, 20,
                             anchor_x="center")
        elif self.attack_phase == "attacking":
            arcade.draw_text("АТАКА! Уклоняйтесь от лучей и рук!", SCREEN_WIDTH // 2, 100, arcade.color.RED, 20,
                             anchor_x="center")
        elif self.attack_phase == "special_warning":
            arcade.draw_text("ОСОБАЯ ФАЗА! Руки исчезают!", SCREEN_WIDTH // 2, 100, arcade.color.PURPLE, 24,
                             anchor_x="center")
        elif self.attack_phase == "special_phase":
            time_left = self.special_phase_max_duration - self.special_phase_duration
            arcade.draw_text(f"ОСОБАЯ ФАЗА! Избегайте красных точек! Осталось: {time_left / 60:.1f} сек",
                             SCREEN_WIDTH // 2, 100, arcade.color.PURPLE, 20, anchor_x="center")

        if self.attack_phase == "idle":
            time_to_attack = max(0, (self.attack_interval - self.attack_timer) // 60)
            arcade.draw_text(f"Следующая атака через: {time_to_attack:.1f} сек", SCREEN_WIDTH // 2, 70,
                             arcade.color.CYAN, 16, anchor_x="center")

        if self.player_hp <= 0 or self.boss_hp <= 0:
            self.draw_game_over_screen()

        if self.game_paused:
            self.draw_pause_screen()

    def draw_game_over_screen(self):
        game_over_points = [
            (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 100),
            (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 - 100),
            (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 + 100),
            (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 100),
        ]
        arcade.draw_polygon_filled(game_over_points, arcade.color.BLACK)
        arcade.draw_polygon_outline(game_over_points, arcade.color.WHITE, 2)

        if self.player_hp <= 0:
            arcade.draw_text("ПОРАЖЕНИЕ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40, arcade.color.RED, 36,
                             anchor_x="center")
            arcade.draw_text("R - рестарт босса, ESC - выход", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20,
                             arcade.color.WHITE, 20, anchor_x="center")
        elif self.boss_hp <= 0:
            arcade.draw_text("ПОБЕДА НАД БОССОМ!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40,
                             arcade.color.GOLD, 36, anchor_x="center")
            arcade.draw_text("Вы прошли игру!", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20,
                             arcade.color.WHITE, 24, anchor_x="center")
            arcade.draw_text("ESC - выход", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50,
                             arcade.color.YELLOW, 20, anchor_x="center")

    def draw_pause_screen(self):
        pause_points = [
            (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 80),
            (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 - 80),
            (SCREEN_WIDTH // 2 + 200, SCREEN_HEIGHT // 2 + 80),
            (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 80),
        ]
        arcade.draw_polygon_filled(pause_points, (0, 0, 0, 200))
        arcade.draw_polygon_outline(pause_points, arcade.color.YELLOW, 2)
        
        arcade.draw_text("ИГРА ПРИОСТАНОВЛЕНА", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30,
                         arcade.color.WHITE, 32, anchor_x="center")
        arcade.draw_text("P - продолжить", SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30,
                         arcade.color.YELLOW, 24, anchor_x="center")

    def on_key_press(self, key, modifiers):
        if key == arcade.key.P:
            self.game_paused = not self.game_paused
            return

        if self.game_paused:
            return

        if self.player_hp <= 0 or self.boss_hp <= 0:
            if key == arcade.key.R:
                self.restart_boss_fight()
            elif key == arcade.key.ESCAPE:
                arcade.close_window()
            return

        if key == arcade.key.UP:
            self.up_pressed = True
        elif key == arcade.key.DOWN:
            self.down_pressed = True
        elif key == arcade.key.LEFT:
            self.left_pressed = True
        elif key == arcade.key.RIGHT:
            self.right_pressed = True
        elif key == arcade.key.SPACE:
            self.player_attack()
        elif key == arcade.key.R:
            self.restart_boss_fight()
        elif key == arcade.key.ESCAPE:
            arcade.close_window()

    def on_key_release(self, key, modifiers):
        if self.game_paused:
            return

        if key == arcade.key.UP:
            self.up_pressed = False
        elif key == arcade.key.DOWN:
            self.down_pressed = False
        elif key == arcade.key.LEFT:
            self.left_pressed = False
        elif key == arcade.key.RIGHT:
            self.right_pressed = False

    def player_attack(self):
        if self.player_hp <= 0 or self.boss_hp <= 0 or self.boss_invulnerable:
            return

        if self.player_attack_cooldown > 0:
            return

        attack_range = 80
        self.player_sprite.set_state("attack",
                                     self.right_pressed or (not self.left_pressed and self.player_sprite.facing_right))
        self.player_attack_cooldown = 15

        distance_x = abs(self.player_x - self.boss_x)
        distance_y = abs(self.player_y - self.boss_y)
        distance = (distance_x ** 2 + distance_y ** 2) ** 0.5

        if distance < attack_range + self.boss_size:
            self.boss_hp -= 10
            if self.boss_hp < 0:
                self.boss_hp = 0

            if not self.boss_invulnerable:
                self.boss_sprite.set_state("damage")

    def start_attack(self):
        self.attack_phase = "moving"
        self.hands_movement_timer = 0

        for i, hand in enumerate(self.hands):
            start_angle, end_angle = self.hand_sectors[i]
            new_angle = random.randint(start_angle, end_angle)

            hand["start_angle"] = hand["angle"]
            hand["target_angle"] = math.radians(new_angle)
            hand["move_progress"] = 0.0
            hand["is_moving"] = True
            hand["warning_timer"] = 0
            hand["attacking"] = False

    def start_special_phase(self):
        self.attack_phase = "special_warning"
        self.attack_duration = 30
        self.boss_invulnerable = True
        self.danger_point_warnings = []
        self.danger_points = []
        self.explosions = []

    def on_update(self, delta_time):
        if self.game_paused or self.game_ended:
            return

        if self.player_hp <= 0 or self.boss_hp <= 0:
            if not self.final_time:
                self.final_time = datetime.now() - self.start_time
                self.game_ended = True
            return

        self.player_sprite.update_animation(delta_time)

        if self.player_attack_cooldown > 0:
            self.player_attack_cooldown -= 1
            if self.player_attack_cooldown == 0:
                self.player_sprite.set_state("idle", self.player_sprite.facing_right)

        if self.boss_sprite.current_state == "damage":
            if self.boss_sprite.current_frame >= len(self.boss_sprite.textures["damage"]) - 1:
                self.boss_sprite.set_state("idle")
        else:
            self.boss_sprite.update_animation(delta_time)

        move_x = 0
        move_y = 0

        if self.up_pressed:
            move_y += self.player_speed
        if self.down_pressed:
            move_y -= self.player_speed
        if self.left_pressed:
            move_x -= self.player_speed
        if self.right_pressed:
            move_x += self.player_speed

        if move_x != 0 or move_y != 0:
            self.player_x += move_x
            self.player_y += move_y

            if move_x != 0:
                self.player_sprite.set_state("run", move_x > 0)
            else:
                self.player_sprite.set_state("run", self.player_sprite.facing_right)
        elif self.player_attack_cooldown == 0:
            self.player_sprite.set_state("idle", self.player_sprite.facing_right)

        self.player_x = max(20, min(SCREEN_WIDTH - 20, self.player_x))
        self.player_y = max(20, min(SCREEN_HEIGHT - 20, self.player_y))

        if self.attack_phase == "special_phase":
            self.special_phase_duration += 1

            if self.special_phase_duration >= self.special_phase_max_duration:
                self.attack_phase = "idle"
                self.boss_invulnerable = False
                self.danger_point_warnings = []
                self.danger_points = []
                self.explosions = []
                self.special_phase_duration = 0
                self.attack_counter = 0
                self.boss_sprite.set_state("idle")

        if self.attack_phase == "idle":
            self.attack_timer += 1
            if self.attack_timer >= self.attack_interval:
                self.start_attack()
                self.attack_timer = 0

        elif self.attack_phase == "moving":
            self.hands_movement_timer += 1

            if self.hands_movement_timer >= 90:
                all_ready = True
                for hand in self.hands:
                    if hand["is_moving"]:
                        all_ready = False
                        break

                if all_ready:
                    self.attack_phase = "warning"
                    self.attack_duration = 48

                    for hand in self.hands:
                        hand["warning_timer"] = 48

        elif self.attack_phase == "warning":
            self.attack_duration -= 1
            if self.attack_duration <= 0:
                self.attack_phase = "attacking"
                self.attack_counter += 1

                if self.attack_counter >= self.special_phase_after_attacks:
                    self.start_special_phase()

        elif self.attack_phase == "attacking":
            all_done = True
            for hand in self.hands:
                if hand["attack_timer"] > 0:
                    all_done = False
                    break

            if all_done:
                self.attack_phase = "idle"

        elif self.attack_phase == "special_warning":
            self.attack_duration -= 1
            if self.attack_duration <= 0:
                self.attack_phase = "special_phase"
                self.special_phase_duration = 0

    def restart_boss_fight(self):
        self.player_x = 400
        self.player_y = 100
        self.player_hp = 150
        self.player_max_hp = 150
        self.player_attack_cooldown = 0

        self.boss_hp = 500
        self.boss_max_hp = 500
        self.boss_invulnerable = False

        self.attack_timer = 0
        self.attack_phase = "idle"
        self.attack_counter = 0
        self.special_phase_duration = 0
        self.hands_movement_timer = 0

        self.danger_point_warnings = []
        self.danger_points = []
        self.explosions = []
        self.hand_contact_timers = {}

        self.hands = []
        self.hand_sprites = []
        self.setup()

        self.player_sprite.set_state("idle", True)

        self.boss_sprite.set_state("idle")

        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False


def main():
    menu = MainMenu()
    menu.center_window()
    arcade.run()


if __name__ == "__main__":
    main()
